r"""
Class for Signed Subsets

AUTHORS:

- Aram Dermenjian (2019-07-12): Initial version
- Elizabeth Flight (2023-08-01): Beta version
- Tudor Tanasa (2023-08-01): Beta version
"""

# ****************************************************************************
#      Copyright (C) 2019   Aram Dermenjian <aram.dermenjian.math at gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.structure.sage_object import SageObject
import copy


class SignedSubsetElement(SageObject):
    r"""
    Implement a basic signed subset element which is used for the
    oriented matroids class.

    INPUT:

    - ``parent`` -- the parent object of the element. Usually is a class
      generated by :class:`OrientedMatroid`.
    - ``data`` -- tuple (default: ``None``); can be given in one of the
      following formats:

      - **as a vector** -- this is a tuple of pluses, minuses, and zeros
      - **as three tuples** -- the first tuple is the positives, the second
        the negatives and the third the zeros
      - **as a dict** -- the dictionary should have keys *positives*,
        *negatives*, and *zeros*

    - ``groundset`` -- (default: ``None``) if not given will construct
      the groundset from the parent, or if none is created in the parent,
      using the elements found in the data
    - ``positives`` -- (default: ``None``) alternative to ``data``; should be
      a tuple of elements and requires ``negatives`` to be set
    - ``negatives`` -- (default: ``None``) alternative to ``data``; should be
      a tuple of elements and requires ``positives`` to be set
    - ``zeros`` -- (default: ``None``) alternative to ``data``; should be a
      tuple of elements and requires ``positives`` and ``negatives`` to be set

    EXAMPLES::

        sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
        sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
        sage: M = OrientedMatroid([[1],[-1]], key='circuit');
        sage: SignedSubsetElement(M,data = (0,))
        +:
        -:
        0: 0
        sage: SignedSubsetElement(M,data = (1,))
        +: 0
        -:
        0:
        sage: M = OrientedMatroid([[1],[-1]], key='circuit', groundset=['e'])
        sage: SignedSubsetElement(M,data = (1,))
        +: e
        -:
        0:

    Elements are also lazy loaded to return the sign of elements from the
    groundset::

        sage: M = OrientedMatroid([[1],[-1]], key='circuit', groundset=['e'])
        sage: C = M.elements(); C[0]
        +: e
        -:
        0:
        sage: C[0]('e')
        1

    .. SEEALSO::

        - :class:`~sage.oriented_matroids.oriented_matroid.OrientedMatroid`
    """
    def __init__(self, parent=None, data=None, groundset=None, positives=None, negatives=None, zeros=None):
        """
        Return a ``SignedSubsetElement`` object.
        
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
            sage: M = OrientedMatroid([[1],[-1]], key='circuit');
            sage: E = SignedSubsetElement(M,data = (0,)); E
            +:
            -:
            0: 0

        TESTS::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
            sage: M = OrientedMatroid([[1],[-1]], key='circuit');
            sage: E = SignedSubsetElement(M,data = (0,))
            sage: TestSuite(E).run()
        """
        self._parent = parent

        # If our groundset isn't set but our parent has one, use its groundset
        if groundset is None:
            try:
                groundset = self._parent.groundset()
            except AttributeError:
                groundset = None

        # instantiate!
        self._p = set([])
        self._n = set([])
        self._z = set([])

        # If we're setting things one item at a time
        if positives is not None:
            if negatives is None:
                raise ValueError(
                    "if positives is set, negatives must be as well")

            self._p = set(positives)
            self._n = set(negatives)
            if zeros is None:
                if groundset is None:
                    self._z = set([])
                else:
                    gs = set(groundset)
                    self._z = gs.difference(self._p).difference(self._n)
            else:
                self._z = set(zeros)

        # If we already have a signed subset element, use it's data
        elif isinstance(data, SignedSubsetElement):
            self._p = data.positives()
            self._n = data.negatives()
            self._z = data.zeros()

        # If we have a tuple, use its information
        elif isinstance(data, tuple):
            # if we're given vector format
            if data[0] in [-1, 0, 1, '+', '0', '-', '']:
                if groundset is not None and len(data) != len(groundset):
                    raise ValueError(
                        "length of vector must be same number of elements as ground set")
                for i, j in enumerate(data):
                    label = i
                    if groundset is not None:
                        label = groundset[i]
                    if j == -1 or j == '-':
                        self._n.add(label)
                    elif j == 1 or j == '+':
                        self._p.add(label)
                    elif j == 0 or j == '' or j == '0':
                        self._z.add(label)
                    else:
                        raise ValueError("must be tuple of -1, 0, 1")

            # If we have a tuple of tuples
            else:
                self._p = set(data[0])
                self._n = set(data[1])
                if len(data) > 2:
                    self._z = set(data[2])
                elif groundset is not None:
                    self._z = set(groundset).difference(
                        self._p).difference(self._n)
        # If we have a dictionary, use the keys to figure it out
        elif isinstance(data, dict):
            if 'p' in data:
                self._p = data['p']
            if 'positives' in data:
                self._p = data['positives']
            if 'n' in data:
                self._n = data['n']
            if 'negatives' in data:
                self._n = data['negatives']
            if 'z' in data:
                self._z = data['z']
            if 'zeros' in data:
                self._z = data['zeros']
        else:
            raise ValueError(
                "either positives and negatives are set or data is a tuple, OrientedMatroidELement or a dict")

        # Type fix
        self._p = set(self._p)
        self._n = set(self._n)
        self._z = set(self._z)

        # Setup the groundset if it's not set yet
        if groundset is None:
            self._g = list(self._p.union(self._n).union(self._z))
        else:
            if not self.support().union(self.zeros()).issubset(groundset):
                raise ValueError("elements must appear in groundset")

            # Update the zeros with everything in the groundset
            if self._z is None:
                self._z = set(groundset).difference(self.support())

            # groundset should be everything
            if not set(groundset).issubset(self.support().union(self.zeros())):
                raise ValueError(
                    "every element must be either positive, negative or zero")
            self._g = groundset

        self._g = list(self._g)

    def __call__(self, var):
        """
        Return the sign of an element in the groundset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: E(1)
            0
            sage: E(0)
            1
            sage: E(2)
            -1
        """
        if var in self.positives():
            return 1
        if var in self.negatives():
            return -1
        if var in self.zeros():
            return 0
        raise ValueError("not in groundset")

    def __hash__(self):
        """
        Return hashed string of signed subset.
        
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: hash(E)
            1231571227600608182
        """
        fsp = frozenset(self._p)
        fsn = frozenset(self._n)
        fsz = frozenset(self._z)
        return hash((fsp, fsn, fsz))

    def __neg__(self):
        """
        Return the opposite signed subset.
                
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]; E
            +: 0
            -: 2
            0: 1
            sage: -E
            +: 2
            -: 0
            0: 1
        """
        N = copy.copy(self)
        N._p = self._n
        N._n = self._p
        return N

    def __eq__(self, other):
        """
        Return whether two elements are equal.
                        
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E1 == E2
            False
            sage: E1 == E1
            True
        """
        if isinstance(other, SignedSubsetElement):
            if self._p == other._p \
                    and self._n == other._n \
                    and self._z == other._z:
                return True
        return False

    def __ne__(self, other):
        """
        Return whether two elements are not equal.        

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E1 != E2
            True
            sage: E1 != E1
            False
        """
        return not (self == other)

    def _cmp_(self, other):
        """
        Arbitrary comparison function so posets work.
        """
        if not isinstance(other, SignedSubsetElement):
            return 0
        return 1
        # x = len(self.support()) - len(other.support())
        # if x == 0:
        #     return x
        # return x / abs(x) * -1

    def __bool__(self):
        r"""
        Return whether an element is not considered a zero.

        For an oriented matroid, we consider the empty set
        `\emptyset = (\emptyset,\emptyset)` to be a zero as
        it is the same as the all zero vector.
        
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]; E1
            +: 0
            -: 2
            0: 1
            sage: bool(E1)
            True
            sage: E3 = M.elements()[2]; E3
            +: 
            -: 
            0: 0,1,2
            sage: bool(E3)
            False
        """
        if len(self.support()) > 0:
            return True
        return False

    def __iter__(self):
        """
        Return an iter version of ``self``.
        """
        for e in self.groundset():
            yield self(e)

    def _repr_(self):
        """
        Return a string of the signed subset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
            sage: C = [((1,4),(2,3)), ((2,3),(1,4))]
            sage: M = OrientedMatroid(C, key='circuit')
            sage: SignedSubsetElement(M, data=((1,4),(2,3)))
            +: 1,4
            -: 2,3
            0:
            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: OrientedMatroid.options.display = 'vector'
            sage: SignedSubsetElement(M, data=((1,4),(2,3)))
            (1,-1,-1,1)
            sage: OrientedMatroid.options.display = 'set'
        """
        from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
        if OrientedMatroid.options.display == 'set':
            p = map(str, self.positives())
            n = map(str, self.negatives())
            z = map(str, self.zeros())
            return "+: " + ','.join(p) + "\n" + \
                "-: " + ','.join(n) + "\n" +\
                "0: " + ','.join(z)
        if OrientedMatroid.options.display == 'vector':
            return "(" + ','.join([str(self(e)) for e in self.groundset()]) + ")"

    def _latex_(self):
        r"""
        Return a latex representation of the signed subset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
            sage: C = [((1,4),(2,3)), ((2,3),(1,4))]
            sage: M = OrientedMatroid(C, key='circuit')
            sage: latex(SignedSubsetElement(M, data=((1,4),(2,3))))
            \left( \left{1,4\right},\left{2,3\right} \right)
            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: OrientedMatroid.options.display = 'vector'
            sage: latex(SignedSubsetElement(M, data =((1,4),(2,3))))
            \left(1,-1,-1,1\right)
        """
        from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
        if OrientedMatroid.options.display == 'set':
            p = map(str, self.positives())
            n = map(str, self.negatives())
            return "\\left( \\left{" + ','.join(p) + \
                "\\right},\\left{" + ','.join(n) + "\\right} \\right)"
        if OrientedMatroid.options.display == 'vector':
            ground_set = [str(self(e)) for e in self.groundset()]
            return "\\left(" + ','.join(ground_set) + "\\right)"

    def __copy__(self):
        """
        Return a copy of the element.
        
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: copy(E) == E
            True
        """
        return SignedSubsetElement(parent=self.parent(), groundset=self.groundset(), positives=self.positives(), negatives=self.negatives(), zeros=self.zeros())

    def __deepcopy__(self, memo):
        """
        Return a copy of the element.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: deepcopy(E) == E
            True
        """
        return SignedSubsetElement(parent=self.parent(), groundset=self.groundset(), positives=self.positives(), negatives=self.negatives(), zeros=self.zeros())

    def parent(self):
        """
        Return parent of ``self``.

        EXAMPLES::
        
            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: E.parent() == M
            True
        """
        return self._parent

    def to_list(self):
        """
        Convert object to a list.
        
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: list(E)
            [1, 0, -1]
        """
        return eval("[" + ','.join([str(self(e)) for e in self.groundset()]) + "]")

    def positives(self):
        """
        Return the set of positives.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,1],[-1,1,-1]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.positives()
            {0, 2}
        """
        return self._p

    def negatives(self):
        """
        Return the set of negatives.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,1],[-1,1,-1]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.negatives()
            {1}
        """
        return self._n

    def zeros(self):
        r"""
        Return the set of zeros.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,0],[-1,1,0]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.zeros()
            {2}
        """
        return self._z

    def support(self):
        r"""
        Return the support set.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,0],[-1,1,0]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.support()
            {0, 1}
        """
        return self._p.union(self._n)

    def groundset(self):
        r"""
        Return the groundset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,0],[-1,1,0]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.groundset()
            [0, 1, 2]
        """
        return self._g

    def composition(self, other):
        r"""
        Return the composition of two elements.

        The composition of two elements `X` and `Y`,
        denoted `X \circ Y` is given componentwise
        where for `e \in E` we have `(X \circ Y)(e) = X(e)`
        if `X(e) \neq 0` else it equals `Y(e)`.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: OrientedMatroid.options.display='vector'
            sage: M = OrientedMatroid([[0],[1],[-1]], key='vector')
            sage: E1 = M.elements()[0]; E2 = M.elements()[1]
            sage: E1.composition(E2)
            (1)
            sage: E2.composition(E1)
            (1)
            sage: E1.composition(E2) == E2.composition(E1)
            True
        """
        p = []
        n = []
        z = []
        for e in self.groundset():
            x = self(e)
            # If x is non-zero, keep its value
            if x == 1:
                p.append(e)
            elif x == -1:
                n.append(e)
            else:
                # else grab the value of the other
                x = other(e)
                if x == 1:
                    p.append(e)
                elif x == -1:
                    n.append(e)
                else:
                    z.append(e)
        return type(self)(self.parent(), positives=p, negatives=n, zeros=z)

    def separation_set(self, other):
        r"""
        Return the separation set between two elements.

        The separation set of two elements `X` and `Y`
        is given by `S(X, Y) = \left\{e \mid X(e) = -Y(e) \neq 0 \right\}`
                
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E1.separation_set(E2)
            {0, 2}
        """
        return self.positives().intersection(other.negatives()).union(self.negatives().intersection(other.positives()))

    def reorientation(self, change_set):
        r"""
        Return the reorientation by a set.

        The reorientation of `X` by some `A \subseteq E` is
        the signed subset (covector) given by `{}_{-A}X` where
        `{}_{-A}X^+ = (X^+ \backslash A) \cup (X^- \cap A)` and similarly for
        `{}_{-A}X^-`.  

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]; E
            (1,0,-1)
            sage: E.reorientation(2)
            (1,0,1)
            sage: E.reorientation([0,1,2])
            (-1,0,1)
        """
        if change_set in self.groundset():
            change_set = set([change_set])
        else:
            change_set = set(change_set)

        # ensure every elt is in the groundset
        for i in change_set:
            if i not in self.groundset():
                raise ValueError(f"{i} is not in the groundset")

        p = self.positives().difference(change_set).union(
            self.negatives().intersection(change_set))
        n = self.negatives().difference(change_set).union(
            self.positives().intersection(change_set))
        return type(self)(self.parent(), positives=p, negatives=n, groundset=self.groundset())

    def restrict_to(self, change_set):
        r"""
        Return the restriction by a set.

        The restriction of `X` by some `F \subseteq E` is the signed subset `Y`
        where `Y^+ = X^+ \cap F` and `Y^- = X^- \cap F`.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]; E
            (1,0,-1)
            sage: E.restrict_to([0])
            (1,0,0)
            sage: E.restrict_to([2])
            (0,0,-1)
            sage: E.restrict_to([1])
            (0,0,0)
        """
        if change_set in self.groundset():
            change_set = set([change_set])
        else:
            change_set = set(change_set)

        p = self.positives().intersection(change_set)
        n = self.negatives().intersection(change_set)
        return type(self)(self.parent(), positives=p, negatives=n, groundset=self.groundset())

    def is_conformal_with(self, other):
        r"""
        Return if the two elements are conformal.

        Two elements `X` and `Y` are *conformal* if
        `S(X,Y) = \emptyset`. This is true if and only if `X^+ \subseteq Y^+`
        and `X^- \subseteq Y^-`.
        
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E3 = M.elements()[2]
            sage: E1.is_conformal_with(E2)
            False
            sage: E1.is_conformal_with(E3)
            True
        """
        return len(self.separation_set(other)) == 0

    def is_orthogonal_with(self, other):
        r"""
        Return if the two elements are orthogonal.

        Two elements `X` and `Y` are orthogonal if either their support is
        empty or the restriction of `X` and `Y` to their intersection are
        neither equal nor opposite.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E3 = M.elements()[2]
            sage: E1.is_orthogonal_with(E2)
            False
            sage: E1.is_orthogonal_with(E3)
            True
        """
        intersection = other.support().intersection(self.support())
        if len(intersection) == 0:
            return True

        s = self.restrict_to(intersection)
        o = other.restrict_to(intersection)
        return (s != o and s != -o)

    def is_restriction_of(self, other):
        r"""
        Return if ``self`` is a restriction of ``other``.

        A signed subset `X` is a *restriction* of a signed subset `Y` if
        `X^+ \subseteq Y^+` and `X^- \subseteq Y^-`. If `X` is a restriction of
        `Y` we sometimes say `X` conforms to `Y`. This should not be mistaken
        with *is conformal with*.  

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E3 = M.elements()[2]
            sage: E2.is_restriction_of(E1)
            False
            sage: E3.is_restriction_of(E1)
            True
        """
        return (self.positives().issubset(other.positives())
                and self.negatives().issubset(other.negatives()))

    def is_tope(self):
        r"""
        Return whether object is a tope.

        A covector is a tope if it is a maximal
        element in the face poset.

        .. WARNING::

            Requires the method ``face_lattice`` to exist in the oriented
            matroid.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E3 = M.elements()[2]
            sage: E1.is_tope()
            True
            sage: E3.is_tope()
            False
        """
        if getattr(self.parent(), 'face_lattice', None) is None:
            raise TypeError(
                "topes are only implemented if .face_lattice() is implemented")

        return self in self.parent().topes()

    def is_simplicial(self):
        r"""
        Return whether or not a tope is simplicial.

        A tope `T` is simplicial if the interval `[0,T]` is boolean
        in the face lattice. We note that the breadth of a lattice
        can characterize this. In particular a lattice of breadth `n`
        contains a sublattice isomorphic to the Boolean lattice of `2^n`
        elements. In other words, if `[0,T]` has `2^n` elements and
        the breadth of `[0,T]` is `n` then the interval is boolean
        and thus `T` is simplicial.
        
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E3 = M.elements()[2]
            sage: E1.is_simplicial()
            True
            sage: E3.is_simplicial()
            Traceback (most recent call last):
            ...
            TypeError: only topes can be simplicial
        """
        if not self.is_tope():
            raise TypeError("only topes can be simplicial")

        P = self.parent().face_lattice()
        I = P.interval(P.bottom(), self)
        PP = P.sublattice(I)
        b = PP.breadth()
        return len(I) == 2**b

    def is_zero(self):
        """
        Return whether or not element is 0.
 
        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]; E1
            (1,0,-1)
            sage: E3 = M.elements()[2]; E3
            (0,0,0)
            sage: E1.is_zero()
            False
            sage: E3.is_zero()
            True
        """
        return not any(self(e) != 0 for e in self.groundset())
