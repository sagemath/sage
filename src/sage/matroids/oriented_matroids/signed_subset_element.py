r"""
Class for Signed Subsets

AUTHORS:

- Aram Dermenjian (2019-07-12): Initial version
- Elizabeth Flight (2023-08-01): Beta version
- Tudor Tanasa (2023-08-01): Beta version
"""

# ****************************************************************************
#      Copyright (C) 2019   Aram Dermenjian <aram.dermenjian.math at gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.structure.sage_object import SageObject


class SignedSubsetElement(SageObject):
    r"""
    Implement a basic signed subset element which is used for the
    oriented matroids class.

    INPUT:

    - ``parent`` -- the parent object of the element. Usually is a class
      generated by :class:`OrientedMatroid`.
    - ``data`` -- tuple (default: ``None``); can be given in one of the
      following formats:

      - **as a vector** -- this is a tuple of pluses, minuses, and zeros
      - **as three tuples** -- the first tuple is the positives, the second
        the negatives and the third the zeros
      - **as a dict** -- the dictionary should have keys *positives*,
        *negatives*, and *zeros*

    - ``groundset`` -- (default: ``None``) if not given will construct
      the groundset from the parent, or if none is created in the parent,
      using the elements found in the data
    - ``positives`` -- (default: ``None``) alternative to ``data``; should be
      a tuple of elements and requires ``negatives`` to be set
    - ``negatives`` -- (default: ``None``) alternative to ``data``; should be
      a tuple of elements and requires ``positives`` to be set
    - ``zeros`` -- (default: ``None``) alternative to ``data``; should be a
      tuple of elements and requires ``positives`` and ``negatives`` to be set

    EXAMPLES::

        sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
        sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
        sage: M = OrientedMatroid([[1],[-1]], key='circuit');
        sage: SignedSubsetElement(M,data = (0,))
        +:
        -:
        0: 0
        sage: SignedSubsetElement(M,data = (1,))
        +: 0
        -:
        0:
        sage: M = OrientedMatroid([[1],[-1]], key='circuit', groundset=['e'])
        sage: SignedSubsetElement(M,data = (1,))
        +: e
        -:
        0:

    Elements are also lazy loaded to return the sign of elements from the
    groundset::

        sage: M = OrientedMatroid([[1],[-1]], key='circuit', groundset=['e'])
        sage: C = M.elements(); C[0]
        +: e
        -:
        0:
        sage: C[0]('e')
        1

    .. SEEALSO::

        - :class:`~sage.oriented_matroids.oriented_matroid.OrientedMatroid`
    """
    def __init__(self, parent=None, data=None, groundset=None, positives=None, negatives=None, zeros=None):
        """
        Return a ``SignedSubsetElement`` object.

        INPUT:

        - ``parent`` -- the parent object of the element. Usually is a class
          generated by :class:`OrientedMatroid`.
        - ``data`` -- tuple (default: ``None``); can be given in one of the
          following formats:

          - **as a vector** -- this is a tuple of pluses, minuses, and zeros
          - **as three tuples** -- the first tuple is the positives, the second
            the negatives and the third the zeros
          - **as a dict** -- the dictionary should have keys *positives*,
            *negatives*, and *zeros*

        - ``groundset`` -- (default: ``None``) if not given will construct
          the groundset from the parent, or if none is created in the parent,
          using the elements found in the data
        - ``positives`` -- (default: ``None``) alternative to ``data``; should be
          a tuple of elements and requires ``negatives`` to be set
        - ``negatives`` -- (default: ``None``) alternative to ``data``; should be
          a tuple of elements and requires ``positives`` to be set
        - ``zeros`` -- (default: ``None``) alternative to ``data``; should be a
          tuple of elements and requires ``positives`` and ``negatives`` to be set

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
            sage: M = OrientedMatroid([[1],[-1]], key='circuit');
            sage: E = SignedSubsetElement(M,data = (0,)); E
            +:
            -:
            0: 0
            sage: E = SignedSubsetElement(M,data = {'p':[], 'n':[], 'z':[0]}); E
            +:
            -:
            0: 0

        TESTS::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
            sage: M = OrientedMatroid([[1],[-1]], key='circuit');
            sage: E = SignedSubsetElement(M,data = (0,))
            sage: TestSuite(E).run()

            sage: E = SignedSubsetElement(M,data = ((1,),(0,)));
            Traceback (most recent call last):
            ...
            ValueError: elements must appear in groundset

            sage: E = SignedSubsetElement(M,data = (1,1));
            Traceback (most recent call last):
            ...
            ValueError: length of vector must be same number of elements as ground set

            sage: E = SignedSubsetElement(M,data = []);
            Traceback (most recent call last):
            ...
            ValueError: either positives and negatives are set or data is a tuple, OrientedMatroidELement or a dict
        """
        self._parent = parent

        # If our groundset isn't set but our parent has one, use its groundset
        if groundset is None and self._parent is not None:
            try:
                groundset = self._parent.groundset()
            except AttributeError:
                groundset = None

        # instantiate!
        self._p = set([])
        self._n = set([])
        self._z = set([])

        # If we're setting things one item at a time
        if positives is not None:
            if negatives is None:
                raise ValueError(
                    "if positives is set, negatives must be as well")

            self._p = set(positives)
            self._n = set(negatives)
            if zeros is None:
                if groundset is None:
                    self._z = set([])
                else:
                    gs = set(groundset)
                    self._z = gs.difference(self._p).difference(self._n)
            else:
                self._z = set(zeros)

        # If we already have a signed subset element, use it's data
        elif isinstance(data, SignedSubsetElement):
            self._p = data.positives()
            self._n = data.negatives()
            self._z = data.zeros()

        # If we have a tuple, use its information
        elif isinstance(data, tuple):
            # if we're given vector format
            if data[0] in [-1, 0, 1, '+', '0', '-', '']:
                if groundset is not None and len(data) != len(groundset):
                    raise ValueError(
                        "length of vector must be same number of elements as ground set")
                for i, j in enumerate(data):
                    label = i
                    if groundset is not None:
                        label = groundset[i]
                    if j in (-1, '-'):
                        self._n.add(label)
                    elif j in (1, '+'):
                        self._p.add(label)
                    elif j in (0, '', '0'):
                        self._z.add(label)
                    else:
                        raise ValueError("must be tuple of -1, 0, 1")

            # If we have a tuple of tuples
            else:
                self._p = set(data[0])
                self._n = set(data[1])
                if len(data) > 2:
                    self._z = set(data[2])
                elif groundset is not None:
                    self._z = set(groundset).difference(
                        self._p).difference(self._n)
        # If we have a dictionary, use the keys to figure it out
        elif isinstance(data, dict):
            if 'p' in data:
                self._p = data['p']
            if 'positives' in data:
                self._p = data['positives']
            if 'n' in data:
                self._n = data['n']
            if 'negatives' in data:
                self._n = data['negatives']
            if 'z' in data:
                self._z = data['z']
            if 'zeros' in data:
                self._z = data['zeros']
        else:
            raise ValueError(
                "either positives and negatives are set or data is a tuple, OrientedMatroidELement or a dict")

        # Type fix
        self._p = set(self._p)
        self._n = set(self._n)
        self._z = set(self._z)

        # Setup the groundset if it's not set yet
        if groundset is None:
            self._g = list(self._p.union(self._n).union(self._z))
        else:
            if not self.support().union(self.zeros()).issubset(groundset):
                raise ValueError("elements must appear in groundset")

            # Update the zeros with everything in the groundset
            if self._z is None:
                self._z = set(groundset).difference(self.support())

            # groundset should be everything
            if not set(groundset).issubset(self.support().union(self.zeros())):
                raise ValueError(
                    "every element must be either positive, negative or zero")
            self._g = groundset

        self._g = list(self._g)

    def __call__(self, var):
        """
        Return the sign of an element in the groundset.

        INPUT:

        - ``var`` - element of the signed set

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: E(1)
            0
            sage: E(0)
            1
            sage: E(2)
            -1
            sage: E(3)
            Traceback (most recent call last):
            ...
            ValueError: 3 is not in the groundset
        """
        if var in self._p:
            return 1
        if var in self._n:
            return -1
        if var in self._z:
            return 0
        raise ValueError(f"{var} is not in the groundset")

    def __hash__(self) -> int:
        """
        Return hashed string of signed subset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: hash(E)
            -3307894506099694323
        """
        fsp = frozenset(self._p)
        fsn = frozenset(self._n)
        fsz = frozenset(self._z)
        fsg = frozenset(self._g)
        return hash((fsp, fsn, fsz, fsg))

    def __neg__(self):
        """
        Return the opposite signed subset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]; E
            +: 0
            -: 2
            0: 1
            sage: -E
            +: 2
            -: 0
            0: 1
        """
        return SignedSubsetElement(parent=self.parent(), groundset=self._g, positives=self._n, negatives=self._p, zeros=self._z)

    def __eq__(self, other) -> bool:
        """
        Return whether two elements are equal.

        INPUT:

        - ``other`` - :class:`SignedSubsetElement` to check against ``self``

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E1 == E2
            False
            sage: E1 == E1
            True
        """
        if isinstance(other, SignedSubsetElement):
            if (
                self._p == other._p
                and self._n == other._n
                and self._z == other._z
            ):
                return True
        return False

    def __ne__(self, other) -> bool:
        """
        Return whether two elements are not equal.

        INPUT:

        - ``other`` - :class:`SignedSubsetElement` to check against ``self``

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E1 != E2
            True
            sage: E1 != E1
            False
        """
        return not (self == other)

    def __bool__(self) -> bool:
        r"""
        Return whether an element is not considered a zero.

        For an oriented matroid, we consider the empty set
        `\emptyset = (\emptyset,\emptyset)` to be a zero as
        it is the same as the all zero vector.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]; E1
            +: 0
            -: 2
            0: 1
            sage: bool(E1)
            True
            sage: E3 = M.elements()[2]; E3
            +:
            -:
            0: 0,1,2
            sage: bool(E3)
            False
        """
        return bool(self.support())

    def __iter__(self):
        """
        Return an iter version of ``self``.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: [e for e in E1]
            [1, 0, -1]
        """
        for e in self._g:
            yield self(e)

    def _repr_(self) -> str:
        """
        Return a string of the signed subset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
            sage: C = [((1,4),(2,3)), ((2,3),(1,4))]
            sage: M = OrientedMatroid(C, key='circuit')
            sage: SignedSubsetElement(M, data=((1,4),(2,3)))
            +: 1,4
            -: 2,3
            0:
            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: OrientedMatroid.options.display = 'vector'
            sage: SignedSubsetElement(M, data=((1,4),(2,3)))
            (1,-1,-1,1)
            sage: OrientedMatroid.options.display = 'set'
        """
        from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
        if OrientedMatroid.options.display == 'set':
            p = map(str, self.positives())
            n = map(str, self.negatives())
            z = map(str, self.zeros())
            return "+: " + ','.join(p) + "\n" + \
                "-: " + ','.join(n) + "\n" +\
                "0: " + ','.join(z)
        if OrientedMatroid.options.display == 'vector':
            return "(" + ','.join([str(self(e)) for e in self.groundset()]) + ")"
        return ""

    def _latex_(self) -> str:
        r"""
        Return a latex representation of the signed subset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: from sage.matroids.oriented_matroids.signed_subset_element import SignedSubsetElement
            sage: C = [((1,4),(2,3)), ((2,3),(1,4))]
            sage: M = OrientedMatroid(C, key='circuit')
            sage: latex(SignedSubsetElement(M, data=((1,4),(2,3))))
            \left( \left{1,4\right},\left{2,3\right} \right)
            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: OrientedMatroid.options.display = 'vector'
            sage: latex(SignedSubsetElement(M, data =((1,4),(2,3))))
            \left(1,-1,-1,1\right)
        """
        from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
        if OrientedMatroid.options.display == 'set':
            p = map(str, self.positives())
            n = map(str, self.negatives())
            return "\\left( \\left{" + ','.join(p) + \
                "\\right},\\left{" + ','.join(n) + "\\right} \\right)"
        if OrientedMatroid.options.display == 'vector':
            ground_set = [str(self(e)) for e in self.groundset()]
            return "\\left(" + ','.join(ground_set) + "\\right)"
        return ""

    def __copy__(self):
        """
        Return a copy of the element.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: copy(E) == E
            True
        """
        return self

    def __deepcopy__(self, memo):
        """
        Return a copy of the element.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: deepcopy(E) == E
            True
        """
        return self

    def parent(self):
        """
        Return parent of ``self``.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: E.parent() == M
            True
        """
        return self._parent

    def to_list(self):
        """
        Convert object to a list.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]
            sage: list(E)
            [1, 0, -1]
        """
        return eval("[" + ','.join([str(self(e)) for e in self.groundset()]) + "]")

    def positives(self):
        """
        Return the set of positives.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,1],[-1,1,-1]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.positives()
            {0, 2}
        """
        return self._p

    def negatives(self):
        """
        Return the set of negatives.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,1],[-1,1,-1]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.negatives()
            {1}
        """
        return self._n

    def zeros(self):
        r"""
        Return the set of zeros.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,0],[-1,1,0]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.zeros()
            {2}
        """
        return self._z

    def support(self):
        r"""
        Return the support set.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,0],[-1,1,0]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.support()
            {0, 1}
        """
        return self._p.union(self._n)

    def groundset(self):
        r"""
        Return the groundset.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: M = OrientedMatroid([[1,-1,0],[-1,1,0]], key='circuit')
            sage: E = M.elements()[0]
            sage: E.groundset()
            [0, 1, 2]
        """
        return self._g

    def composition(self, other):
        r"""
        Return the composition of two elements.

        The composition of two elements `X` and `Y`,
        denoted `X \circ Y` is given componentwise
        where for `e \in E` we have `(X \circ Y)(e) = X(e)`
        if `X(e) \neq 0` else it equals `Y(e)`.

        INPUT:

        - ``other`` - :class:`SignedSubsetElement` to do composition with ``self``

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: OrientedMatroid.options.display='vector'
            sage: M = OrientedMatroid([[0],[1],[-1]], key='vector')
            sage: E1 = M.elements()[0]; E2 = M.elements()[1]
            sage: E1.composition(E2)
            (1)
            sage: E2.composition(E1)
            (1)
            sage: E1.composition(E2) == E2.composition(E1)
            True
        """
        p = []
        n = []
        z = []
        for e in self._g:
            # If x is non-zero, keep its value
            if e in self._p:
                p.append(e)
            elif e in self._n:
                n.append(e)
            # else grab the value of the other
            elif e in other._p:
                p.append(e)
            elif e in other._n:
                n.append(e)
            else:
                z.append(e)
        return type(self)(self.parent(), positives=p, negatives=n, zeros=z)

    def separation_set(self, other):
        r"""
        Return the separation set between two elements.

        The separation set of two elements `X` and `Y`
        is given by `S(X, Y) = \left\{e \mid X(e) = -Y(e) \neq 0 \right\}`

        INPUT:

        - ``other`` - :class:`SignedSubsetElement` to look at the separation
          set with ``self``

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E1.separation_set(E2)
            {0, 2}
        """
        return self._p.intersection(other._n).union(self._n.intersection(other._p))

    def reorientation(self, change_set):
        r"""
        Return the reorientation by a set.

        The reorientation of `X` by some `A \subseteq E` is
        the signed subset (covector) given by `{}_{-A}X` where
        `{}_{-A}X^+ = (X^+ \backslash A) \cup (X^- \cap A)` and similarly for
        `{}_{-A}X^-`.

        INPUT:

        - ``change_set`` - element from ground set or list of elements from ground set

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]; E
            (1,0,-1)
            sage: E.reorientation(2)
            (1,0,1)
            sage: E.reorientation([0,1,2])
            (-1,0,1)
            sage: E.reorientation([3])
            Traceback (most recent call last):
            ...
            ValueError: 3 is not in the groundset
        """
        if change_set in self.groundset():
            change_set = set([change_set])
        else:
            change_set = set(change_set)

        # ensure every elt is in the groundset
        for i in change_set:
            if i not in self._g:
                raise ValueError(f"{i} is not in the groundset")

        p = self.positives().difference(change_set).union(
            self.negatives().intersection(change_set))
        n = self.negatives().difference(change_set).union(
            self.positives().intersection(change_set))
        return type(self)(self.parent(), positives=p, negatives=n, groundset=self.groundset())

    def restrict_to(self, change_set):
        r"""
        Return the restriction by a set.

        The restriction of `X` by some `F \subseteq E` is the signed subset `Y`
        where `Y^+ = X^+ \cap F` and `Y^- = X^- \cap F`.

        INPUT:

        - ``change_set`` - element from ground set or list of elements from ground set

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E = M.elements()[0]; E
            (1,0,-1)
            sage: E.restrict_to([0])
            (1,0,0)
            sage: E.restrict_to([2])
            (0,0,-1)
            sage: E.restrict_to([1])
            (0,0,0)
            sage: E.restrict_to(1)
            (0,0,0)
        """
        if change_set in self.groundset():
            change_set = set([change_set])
        else:
            change_set = set(change_set)

        p = self.positives().intersection(change_set)
        n = self.negatives().intersection(change_set)
        return type(self)(self.parent(), positives=p, negatives=n, groundset=self.groundset())

    def is_conformal_with(self, other) -> bool:
        r"""
        Return if the two elements are conformal.

        Two elements `X` and `Y` are *conformal* if
        `S(X,Y) = \emptyset`. This is true if and only if `X^+ \subseteq Y^+`
        and `X^- \subseteq Y^-`.

        INPUT:

        - ``other`` - :class:`SignedSubsetElement` to check conformality with ``self``

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E3 = M.elements()[2]
            sage: E1.is_conformal_with(E2)
            False
            sage: E1.is_conformal_with(E3)
            True
        """
        return not self.separation_set(other)

    def is_orthogonal_with(self, other) -> bool:
        r"""
        Return if the two elements are orthogonal.

        Two elements `X` and `Y` are orthogonal if either their support is
        empty or the restriction of `X` and `Y` to their intersection are
        neither equal nor opposite.

        INPUT:

        - ``other`` - :class:`SignedSubsetElement` to check orthogonality with ``self``

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E3 = M.elements()[2]
            sage: E1.is_orthogonal_with(E2)
            False
            sage: E1.is_orthogonal_with(E3)
            True
        """
        intersection = other.support().intersection(self.support())
        if not intersection:
            return True

        s = self.restrict_to(intersection)
        o = other.restrict_to(intersection)
        return (s != o and s != -o)

    def is_restriction_of(self, other) -> bool:
        r"""
        Return if ``self`` is a restriction of ``other``.

        A signed subset `X` is a *restriction* of a signed subset `Y` if
        `X^+ \subseteq Y^+` and `X^- \subseteq Y^-`. If `X` is a restriction of
        `Y` we sometimes say `X` conforms to `Y`. This should not be mistaken
        with *is conformal with*.

        INPUT:

        - ``other`` - :class:`SignedSubsetElement` to take restriction of with ``self``

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E2 = M.elements()[1]
            sage: E3 = M.elements()[2]
            sage: E2.is_restriction_of(E1)
            False
            sage: E3.is_restriction_of(E1)
            True
        """
        return (self.positives().issubset(other.positives())
                and self.negatives().issubset(other.negatives()))

    def is_tope(self) -> bool:
        r"""
        Return whether object is a tope.

        A covector is a tope if it is a maximal
        element in the face poset.

        .. WARNING::

            Requires the method ``face_lattice`` to exist in the oriented
            matroid.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E3 = M.elements()[2]
            sage: E1.is_tope()
            True
            sage: E3.is_tope()
            False
        """
        return self in self.parent().topes()

    def is_simplicial(self) -> bool:
        r"""
        Return whether or not a tope is simplicial.

        A tope `T` is simplicial if the interval `[0,T]` is boolean
        in the face lattice. We note that the breadth of a lattice
        can characterize this. In particular a lattice of breadth `n`
        contains a sublattice isomorphic to the Boolean lattice of `2^n`
        elements. In other words, if `[0,T]` has `2^n` elements and
        the breadth of `[0,T]` is `n` then the interval is boolean
        and thus `T` is simplicial.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]
            sage: E3 = M.elements()[2]
            sage: E1.is_simplicial()
            True
            sage: E3.is_simplicial()
            Traceback (most recent call last):
            ...
            TypeError: only topes can be simplicial
        """
        if not self.is_tope():
            raise TypeError("only topes can be simplicial")

        P = self.parent().face_lattice()
        interval = P.interval(P.bottom(), self)
        PP = P.sublattice(interval)
        b = PP.breadth()
        return len(interval) == 2 ** b

    def is_zero(self) -> bool:
        """
        Return whether or not element is 0.

        EXAMPLES::

            sage: from sage.matroids.oriented_matroids.oriented_matroid import OrientedMatroid
            sage: C = [[1, 0, -1], [-1, 0, 1],[0, 0, 0]]
            sage: M = OrientedMatroid(C, key='covector')
            sage: E1 = M.elements()[0]; E1
            (1,0,-1)
            sage: E3 = M.elements()[2]; E3
            (0,0,0)
            sage: E1.is_zero()
            False
            sage: E3.is_zero()
            True
        """
        return all(e in self._z for e in self._g)
