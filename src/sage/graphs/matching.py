r"""
Matching

This module implements the functions pertaining to matching of undirected
graphs. A *matching* in a graph is a set of pairwise nonadjacent links
(nonloop edges). In other words, a matching in a graph is the edge set of an
1-regular subgraph. A matching is called a *perfect* *matching* if it the
subgraph generated by a set of matching edges spans the graph, i.e. it's the
edge set of an 1-regular spanning subgraph.

The implemented methods are listed below:

.. csv-table::
    :class: contentstable
    :widths: 30, 70
    :delim: |

    :meth:`~has_perfect_matching` | Return whether the graph has a perfect matching
    :meth:`~is_bicritical` | Check if the graph is bicritical
    :meth:`~is_factor_critical` | Check whether the graph is factor-critical
    :meth:`~is_matching_covered` | Check if the graph is matching covered
    :meth:`~matching` | Return a maximum weighted matching of the graph represented by the list of its edges
    :meth:`~perfect_matchings` | Return an iterator over all perfect matchings of the graph
    :meth:`~M_alternating_even_mark` | Return the vertices reachable from the provided vertex via an even alternating path starting with a non-matching edge

AUTHORS:

- Robert L. Miller (2006-10-22): initial implementations

- Janmenjaya Panda (2024-06-17): added
  :meth:`~M_alternating_even_mark`,
  :meth:`~is_bicritical` and
  :meth:`~is_matching_covered`


Methods
-------
"""

# ****************************************************************************
#       Copyright (C) 2006 Robert L. Miller
#                     2024 Janmenjaya Panda
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************
import itertools
from __future__ import annotations
from sage.rings.integer import Integer
from sage.graphs.views import EdgesView


def has_perfect_matching(G, algorithm='Edmonds', solver=None, verbose=0,
                         *, integrality_tolerance=1e-3):
    r"""
    Return whether the graph has a perfect matching.

    INPUT:

    - ``algorithm`` -- string (default: ``'Edmonds'``)

      - ``'Edmonds'`` uses Edmonds' algorithm as implemented in NetworkX to
        find a matching of maximal cardinality, then check whether this
        cardinality is half the number of vertices of the graph.

      - ``'LP_matching'`` uses a Linear Program to find a matching of
        maximal cardinality, then check whether this cardinality is half the
        number of vertices of the graph.

      - ``'LP'`` uses a Linear Program formulation of the perfect matching
        problem: put a binary variable ``b[e]`` on each edge `e`, and for
        each vertex `v`, require that the sum of the values of the edges
        incident to `v` is 1.

      - ``'Micali-Vazirani'`` uses the Micali-Vazirani algorithm

    - ``solver`` -- string (default: ``None``); specifies a Mixed Integer
      Linear Programming (MILP) solver to be used. If set to ``None``, the
      default one is used. For more information on MILP solvers and which
      default solver is used, see the method :meth:`solve
      <sage.numerical.mip.MixedIntegerLinearProgram.solve>` of the class
      :class:`MixedIntegerLinearProgram
      <sage.numerical.mip.MixedIntegerLinearProgram>`.

    - ``verbose`` -- integer (default: 0); sets the level of verbosity:
      set to 0 by default, which means quiet (only useful when
      ``algorithm == "LP_matching"`` or ``algorithm == "LP"``)

    - ``integrality_tolerance`` -- float; parameter for use with MILP
      solvers over an inexact base ring; see
      :meth:`MixedIntegerLinearProgram.get_values`.

    OUTPUT: boolean

    EXAMPLES::

        sage: graphs.PetersenGraph().has_perfect_matching()                         # needs networkx
        True
        sage: graphs.WheelGraph(6).has_perfect_matching()                           # needs networkx
        True
        sage: graphs.WheelGraph(5).has_perfect_matching()                           # needs networkx
        False
        sage: graphs.PetersenGraph().has_perfect_matching(algorithm='LP_matching')  # needs sage.numerical.mip
        True
        sage: graphs.WheelGraph(6).has_perfect_matching(algorithm='LP_matching')    # needs sage.numerical.mip
        True
        sage: graphs.WheelGraph(5).has_perfect_matching(algorithm='LP_matching')
        False
        sage: graphs.PetersenGraph().has_perfect_matching(algorithm='LP_matching')  # needs sage.numerical.mip
        True
        sage: graphs.WheelGraph(6).has_perfect_matching(algorithm='LP_matching')    # needs sage.numerical.mip
        True
        sage: graphs.WheelGraph(5).has_perfect_matching(algorithm='LP_matching')
        False
        sage: graphs.PetersenGraph().has_perfect_matching(algorithm='Micali-Vazirani')
        True
        sage: graphs.WheelGraph(6).has_perfect_matching(algorithm='Micali-Vazirani')
        True
        sage: graphs.WheelGraph(5).has_perfect_matching(algorithm='Micali-Vazirani')
        False

    TESTS::

        sage: G = graphs.EmptyGraph()
        sage: all(G.has_perfect_matching(algorithm=algo)                            # needs networkx, sage.numerical.mip, sage.graphs.micali_vazirani_matching
        ....:     for algo in ['Edmonds', 'LP_matching', 'LP', 'Micali-Vazirani'])
        True

    Be careful with isolated vertices::

        sage: G = graphs.PetersenGraph()
        sage: G.add_vertex(11)
        sage: any(G.has_perfect_matching(algorithm=algo)                            # needs networkx, sage.numerical.mip, sage.graphs.micali_vazirani_matching
        ....:     for algo in ['Edmonds', 'LP_matching', 'LP', 'Micali-Vazirani'])
        False
    """
    if G.order() % 2:
        return False

    if algorithm in ["Edmonds", "Micali-Vazirani"]:
        return len(G) == 2*G.matching(value_only=True,
                                      use_edge_labels=False,
                                      algorithm=algorithm)
    elif algorithm == "LP_matching":
        return len(G) == 2*G.matching(value_only=True,
                                      use_edge_labels=False,
                                      algorithm='LP',
                                      solver=solver,
                                      verbose=verbose,
                                      integrality_tolerance=integrality_tolerance)
    elif algorithm == "LP":
        from sage.numerical.mip import MixedIntegerLinearProgram, MIPSolverException
        p = MixedIntegerLinearProgram(solver=solver)
        b = p.new_variable(binary=True)
        for v in G:
            edges = G.edges_incident(v, labels=False)
            if not edges:
                return False
            p.add_constraint(p.sum(b[frozenset(e)] for e in edges) == 1)
        try:
            p.solve(log=verbose)
            return True
        except MIPSolverException:
            return False
    raise ValueError('algorithm must be set to "Edmonds", "LP_matching", "LP"'
                     'or "Micali-Vazirani"')


def is_bicritical(G, matching=None, algorithm='Edmonds', coNP_certificate=False,
                  solver=None, verbose=0, *, integrality_tolerance=0.001):
    r"""
    Check if the graph is bicritical.

    A nontrivial graph `G` is *bicritical* if `G - u - v` has a perfect
    matching for any two distinct vertices `u` and `v` of `G`. Bicritical
    graphs are special kind of matching covered graphs. Each maximal barrier of
    a bicritical graph is a singleton. Thus, for a bicritical graph, the
    canonical partition of the vertex set is the set of sets where each set is
    an individual vertex. Three-connected bicritical graphs, aka *bricks*, play
    an important role in the theory of matching covered graphs.

    This method implements the algorithm proposed in [LZ2001]_ and we
    assume that a connected graph of order two is bicritical, whereas a
    disconnected graph of the same order is not. The time complexity of
    the algorithm is `\mathcal{O}(|V| \cdot |E|)`, if a perfect matching of
    the graph is given, where `|V|` and `|E|` are the order and the size of
    the graph respectively. Otherwise, time complexity may be dominated by
    the time needed to compute a maximum matching of the graph.

    Note that a :class:`ValueError` is returned if the graph has loops or if
    the graph is trivial, i.e., it has at most one vertex.

    INPUT:

    - ``matching`` -- (default: ``None``); a perfect matching of the
      graph, that can be given using any valid input format of
      :class:`~sage.graphs.graph.Graph`.

      If set to ``None``, a matching is computed using the other parameters.

    - ``algorithm`` -- string (default: ``'Edmonds'``); the algorithm to be
      used to compute a maximum matching of the graph among

      - ``'Edmonds'`` selects Edmonds' algorithm as implemented in NetworkX,

      - ``'LP'`` uses a Linear Program formulation of the matching problem.

      - ``'Micali-Vazirani'`` uses the Micali-Vazirani algorithm.

    - ``coNP_certificate`` -- boolean (default: ``False``); if set to
      ``True`` a set of pair of vertices (say `u` and `v`) is returned such
      that `G - u - v` does not have a perfect matching if `G` is not
      bicritical or otherwise ``None`` is returned.

    - ``solver`` -- string (default: ``None``); specify a Mixed Integer
      Linear Programming (MILP) solver to be used. If set to ``None``, the
      default one is used. For more information on MILP solvers and which
      default solver is used, see the method :meth:`solve
      <sage.numerical.mip.MixedIntegerLinearProgram.solve>` of the class
      :class:`MixedIntegerLinearProgram
      <sage.numerical.mip.MixedIntegerLinearProgram>`.

    - ``verbose`` -- integer (default: ``0``); sets the level of verbosity:
      set to 0 by default, which means quiet (only useful when ``algorithm
      == 'LP'``).

    - ``integrality_tolerance`` -- float; parameter for use with MILP
      solvers over an inexact base ring; see
      :meth:`MixedIntegerLinearProgram.get_values`.

    OUTPUT:

    - A boolean indicating whether the graph is bicritical or not.

    - If ``coNP_certificate`` is set to ``True``, a set of pair of vertices
      is returned in case the graph is not bicritical otherwise ``None`` is
      returned.

    EXAMPLES:

    The Petersen graph is bicritical::

        sage: G = graphs.PetersenGraph()
        sage: G.is_bicritical()
        True

    A graph (without a self-loop) is bicritical if and only if the underlying
    simple graph is bicritical::

        sage: G = graphs.PetersenGraph()
        sage: G.allow_multiple_edges(True)
        sage: G.add_edge(0, 5)
        sage: G.is_bicritical()
        True

    A nontrivial circular ladder graph whose order is not divisible by 4 is bicritical::

        sage: G = graphs.CircularLadderGraph(5)
        sage: G.is_bicritical()
        True

    The graph obtained by splicing two bicritical graph is also bicritical.
    For instance, `K_4` with one extra (multiple) edge (say `G := K_4^+`) is
    bicritical. Let `H := K_4^+ \odot K_4^+` such that `H` is free of multiple
    edge. The graph `H` is also bicritical::

        sage: G = graphs.CompleteGraph(4)
        sage: G.allow_multiple_edges(True)
        sage: G.add_edge(0, 1)
        sage: G.is_bicritical()
        True
        sage: H = Graph()
        sage: H.add_edges([
        ....:    (0, 1), (0, 2), (0, 3), (0, 4), (1, 2),
        ....:    (1, 5), (2, 5), (3, 4), (3, 5), (4, 5)
        ....: ])
        sage: H.is_bicritical()
        True

    A graph (of order more than two) with more that one component is not bicritical::

        sage: G = graphs.CycleGraph(4)
        sage: G += graphs.CycleGraph(6)
        sage: G.connected_components_number()
        2
        sage: G.is_bicritical()
        False

    A graph (of order more than two) with a cut-vertex is not bicritical::

        sage: G = graphs.CycleGraph(6)
        sage: G.add_edges([(5, 6), (5, 7), (6, 7)])
        sage: G.is_cut_vertex(5)
        True
        sage: G.has_perfect_matching()
        True
        sage: G.is_bicritical()
        False

    A connected graph of order two is assumed to be bicritical, whereas the
    disconnected graph of the same order is not::

        sage: G = graphs.CompleteBipartiteGraph(1, 1)
        sage: G.is_bicritical()
        True
        sage: G = graphs.CompleteBipartiteGraph(2, 0)
        sage: G.is_bicritical()
        False

    A bipartite graph of order three or more is not bicritical::

        sage: G = graphs.CompleteBipartiteGraph(3, 3)
        sage: G.has_perfect_matching()
        True
        sage: G.is_bicritical()
        False

    One may specify a matching::

        sage: G = graphs.WheelGraph(10)
        sage: M = G.matching()
        sage: G.is_bicritical(matching=M)
        True
        sage: H = graphs.HexahedralGraph()
        sage: N = H.matching()
        sage: H.is_bicritical(matching=N)
        False

    One may ask for a co-`\mathcal{NP}` certificate::

        sage: G = graphs.CompleteGraph(14)
        sage: G.is_bicritical(coNP_certificate=True)
        (True, None)
        sage: H = graphs.CircularLadderGraph(20)
        sage: M = H.matching()
        sage: H.is_bicritical(matching=M, coNP_certificate=True)
        (False, {0, 2})

    TESTS:

    If the graph is trivial::

        sage: G = Graph()
        sage: G.is_bicritical()
        Traceback (most recent call last):
        ...
        ValueError: the graph is trivial
        sage: H = graphs.CycleGraph(1)
        sage: H.is_bicritical()
        Traceback (most recent call last):
        ...
        ValueError: the graph is trivial

    Providing with a wrong matching::

        sage: G = graphs.CompleteGraph(6)
        sage: M = Graph(G.matching())
        sage: M.add_edges([(0, 1), (0, 2)])
        sage: G.is_bicritical(matching=M)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a matching
        sage: N = Graph(G.matching())
        sage: N.add_edge(6, 7)
        sage: G.is_bicritical(matching=N)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a matching of the graph
        sage: J = Graph()
        sage: J.add_edges([(0, 1), (2, 3)])
        sage: G.is_bicritical(matching=J)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a perfect matching of the graph

    Providing with a graph with a self-loop::

        sage: G = graphs.CompleteGraph(4)
        sage: G.allow_loops(True)
        sage: G.add_edge(0, 0)
        sage: G.is_bicritical()
        Traceback (most recent call last):
        ...
        ValueError: This method is not known to work on graphs with loops.
        Perhaps this method can be updated to handle them, but in the meantime
        if you want to use it please disallow loops using allow_loops().

    REFERENCES:

    - [LM2024]_

    - [LZ2001]_

    .. SEEALSO::
        :meth:`~sage.graphs.graph.Graph.is_factor_critical`,
        :meth:`~sage.graphs.graph.Graph.is_matching_covered`

    AUTHORS:

    - Janmenjaya Panda (2024-06-17)
    """
    # The graph must be simple
    G._scream_if_not_simple(allow_multiple_edges=True)

    # The graph must be nontrivial
    if G.order() < 2:
        raise ValueError("the graph is trivial")

    # A graph of order two is assumed to be bicritical
    if G.order() == 2:
        if G.is_connected():
            return (True, None) if coNP_certificate else True
        else:
            return (False, None) if coNP_certificate else False

    # The graph must have an even number of vertices
    if G.order() % 2:
        return (False, set(list(G)[:2])) if coNP_certificate else False

    # The graph must be connected
    if not G.is_connected():
        if not coNP_certificate:
            return False

        components = G.connected_components(sort=False)

        # Check if there is an odd component with at least three vertices
        for component in components:
            if len(component) % 2 and len(component) > 2:
                return (False, set(component[:2]))

        # Check if there are at least two even components
        components_of_even_order = [component for component in components if len(component) % 2 == 0]
        if len(components_of_even_order) > 1:
            return (False, set([components_of_even_order[0][0], components_of_even_order[1][0]]))

        # Or otherwise there is at most one even component with at least two trivial odd components
        u, v = None, None

        for component in components:
            if u is not None and not len(component) % 2:
                v = component[0]
                return (False, {u, v})
            elif len(component) == 1:
                u = component[0]

    # Bipartite graphs of order at least three are not bicritical
    if G.is_bipartite():
        if not coNP_certificate:
            return False

        A, B = G.bipartite_sets()

        if len(A) > 1:
            return (False, set(list(A)[:2]))
        return (False, set(list(B)[:2]))

    from sage.graphs.graph import Graph
    if matching:
        # The input matching must be a valid perfect matching of the graph
        M = Graph(matching)
        if any(d != 1 for d in M.degree()):
            raise ValueError("the input is not a matching")

        if any(not G.has_edge(edge) for edge in M.edge_iterator()):
            raise ValueError("the input is not a matching of the graph")

        if (G.order() != M.order()) or (G.order() != 2*M.size()):
            raise ValueError("the input is not a perfect matching of the graph")
    else:
        # A maximum matching of the graph is computed
        M = Graph(G.matching(algorithm=algorithm, solver=solver, verbose=verbose,
                             integrality_tolerance=integrality_tolerance))

        # It must be a perfect matching
        if G.order() != M.order():
            u, v = next(M.edge_iterator(labels=False))
            return (False, {u, v}) if coNP_certificate else False

    # G is bicritical if and only if for each vertex u with its
    # M-matched neighbor being v, every vertex of the graph distinct
    # from v must be reachable from u through an even length
    # M-alternating uv-path starting with an edge not in M and ending
    # with an edge in M

    for u in G:
        v = next(M.neighbor_iterator(u))

        even = M_alternating_even_mark(G, u, M)

        for w in G:
            if w != v and w not in even:
                return (False, {v, w}) if coNP_certificate else False

    return (True, None) if coNP_certificate else True


def is_factor_critical(G, matching=None, algorithm='Edmonds', solver=None, verbose=0,
                       *, integrality_tolerance=0.001):
    r"""
    Check whether the graph is factor-critical.

    A graph of order `n` is *factor-critical* if every subgraph of `n-1`
    vertices have a perfect matching, hence `n` must be odd. See
    :wikipedia:`Factor-critical_graph` for more details.

    This method implements the algorithm proposed in [LR2004]_ and we assume
    that a graph of order one is factor-critical. The time complexity of the
    algorithm is linear if a near perfect matching is given as input (i.e.,
    a matching such that all vertices but one are incident to an edge of the
    matching). Otherwise, the time complexity is dominated by the time
    needed to compute a maximum matching of the graph.

    INPUT:

    - ``matching`` -- (default: ``None``); a near perfect matching of the
      graph, that is a matching such that all vertices of the graph but one
      are incident to an edge of the matching. It can be given using any
      valid input format of :class:`~sage.graphs.graph.Graph`.

      If set to ``None``, a matching is computed using the other parameters.

    - ``algorithm`` -- string (default: ``'Edmonds'``); the algorithm to use
      to compute a maximum matching of the graph among

      - ``'Edmonds'`` selects Edmonds' algorithm as implemented in NetworkX

      - ``'LP'`` uses a Linear Program formulation of the matching problem

      - ``'Micali-Vazirani'`` uses the Micali-Vazirani algorithm

    - ``solver`` -- string (default: ``None``); specifies a Mixed Integer
      Linear Programming (MILP) solver to be used. If set to ``None``, the
      default one is used. For more information on MILP solvers and which
      default solver is used, see the method :meth:`solve
      <sage.numerical.mip.MixedIntegerLinearProgram.solve>` of the class
      :class:`MixedIntegerLinearProgram
      <sage.numerical.mip.MixedIntegerLinearProgram>`.

    - ``verbose`` -- integer (default: 0); sets the level of verbosity:
      set to 0 by default, which means quiet (only useful when ``algorithm
      == "LP"``)

    - ``integrality_tolerance`` -- float; parameter for use with MILP
      solvers over an inexact base ring; see
      :meth:`MixedIntegerLinearProgram.get_values`.

    EXAMPLES:

    Odd length cycles and odd cliques of order at least 3 are
    factor-critical graphs::

        sage: [graphs.CycleGraph(2*i + 1).is_factor_critical() for i in range(5)]   # needs networkx
        [True, True, True, True, True]
        sage: [graphs.CompleteGraph(2*i + 1).is_factor_critical() for i in range(5)]            # needs networkx
        [True, True, True, True, True]

    More generally, every Hamiltonian graph with an odd number of vertices
    is factor-critical::

        sage: G = graphs.RandomGNP(15, .2)
        sage: G.add_path([0..14])
        sage: G.add_edge(14, 0)
        sage: G.is_hamiltonian()
        True
        sage: G.is_factor_critical()                                                # needs networkx
        True

    Friendship graphs are non-Hamiltonian factor-critical graphs::

        sage: all(graphs.FriendshipGraph(i).is_factor_critical() for i in range(1, 5))             # needs networkx
        True

    Bipartite graphs are not factor-critical::

        sage: G = graphs.RandomBipartite(randint(1, 10), randint(1, 10), .5)        # needs numpy
        sage: G.is_factor_critical()                                                # needs numpy
        False

    Graphs with even order are not factor critical::

        sage: G = graphs.RandomGNP(10, .5)
        sage: G.is_factor_critical()
        False

    One can specify a matching::

        sage: F = graphs.FriendshipGraph(4)
        sage: M = F.matching()                                                      # needs networkx
        sage: F.is_factor_critical(matching=M)                                      # needs networkx
        True
        sage: F.is_factor_critical(matching=Graph(M))                               # needs networkx
        True

    TESTS:

    Giving a wrong matching::

        sage: G = graphs.RandomGNP(15, .3)
        sage: while not G.is_biconnected():
        ....:     G = graphs.RandomGNP(15, .3)
        sage: M = G.matching()                                                      # needs networkx
        sage: G.is_factor_critical(matching=M[:-1])                                 # needs networkx
        Traceback (most recent call last):
        ...
        ValueError: the input is not a near perfect matching of the graph
        sage: G.is_factor_critical(matching=G.edges(sort=True))
        Traceback (most recent call last):
        ...
        ValueError: the input is not a matching
        sage: M = [(2*i, 2*i + 1) for i in range(9)]
        sage: G.is_factor_critical(matching=M)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a matching of the graph
    """
    if G.order() == 1:
        return True

    # The graph must have an odd number of vertices, be 2-edge connected, so
    # without bridges, and not bipartite
    if (not G.order() % 2 or not G.is_connected() or
            list(G.bridges()) or G.is_bipartite()):
        return False

    from sage.graphs.graph import Graph
    if matching:
        # We check that the input matching is a valid near perfect matching
        # of the graph.
        M = Graph(matching)
        if any(d != 1 for d in M.degree()):
            raise ValueError("the input is not a matching")
        if not M.is_subgraph(G, induced=False):
            raise ValueError("the input is not a matching of the graph")
        if (G.order() != M.order() + 1) or (G.order() != 2*M.size() + 1):
            raise ValueError("the input is not a near perfect matching of the graph")
    else:
        # We compute a maximum matching of the graph
        M = Graph(G.matching(algorithm=algorithm, solver=solver, verbose=verbose,
                             integrality_tolerance=integrality_tolerance))

        # It must be a near-perfect matching
        if G.order() != M.order() + 1:
            return False

    # We find the unsaturated vertex u, i.e., the only vertex of the graph
    # not in M
    for u in G:
        if u not in M:
            break

    # We virtually build an M-alternating tree T
    from queue import Queue
    Q = Queue()
    Q.put(u)
    even = set([u])
    odd = set()
    pred = {u: u}
    rank = {u: 0}

    while not Q.empty():
        x = Q.get()
        for y in G.neighbor_iterator(x):
            if y in odd:
                continue
            elif y in even:
                # Search for the nearest common ancestor t of x and y
                P = [x]
                R = [y]
                while P[-1] != R[-1]:
                    if rank[P[-1]] > rank[R[-1]]:
                        P.append(pred[P[-1]])
                    elif rank[P[-1]] < rank[R[-1]]:
                        R.append(pred[R[-1]])
                    else:
                        P.append(pred[P[-1]])
                        R.append(pred[R[-1]])
                t = P.pop()
                R.pop()
                # Set t as pred of all vertices of the chains and add
                # vertices marked odd to the queue

                for a in itertools.chain(P, R):
                    pred[a] = t
                    rank[a] = rank[t] + 1
                    if a in odd:
                        even.add(a)
                        odd.discard(a)
                        Q.put(a)
            else:  # y has not been visited yet
                z = next(M.neighbor_iterator(y))
                odd.add(y)
                even.add(z)
                Q.put(z)
                pred[y] = x
                pred[z] = y
                rank[y] = rank[x] + 1
                rank[z] = rank[y] + 1

    # The graph is factor critical if all vertices are marked even
    return len(even) == G.order()


def is_matching_covered(G, matching=None, algorithm='Edmonds', coNP_certificate=False,
                        solver=None, verbose=0, *, integrality_tolerance=0.001):
    r"""
    Check if the graph is matching covered.

    A connected nontrivial graph wherein each edge participates in some
    perfect matching is called a *matching* *covered* *graph*.

    If a perfect matching of the graph is provided, for bipartite graph,
    this method implements a linear time algorithm as proposed in [LM2024]_
    that is based on the following theorem:

    Given a connected bipartite graph `G[A, B]` with a perfect matching
    `M`. Construct a directed graph `D` from `G` such that `V(D) := V(G)`
    and for each edge in `G` direct the corresponding edge from `A` to `B`
    in `D`, if it is in `M` or otherwise direct it from `B` to `A`. The
    graph `G` is matching covered if and only if `D` is strongly connected.

    For nonbipartite graph, if a perfect matching of the graph is provided,
    this method implements an `\mathcal{O}(|V| \cdot |E|)` algorithm, where
    `|V|` and `|E|` are the order and the size of the graph respectively.
    This implementation is inspired by the `M`-`alternating` `tree` `search`
    method explained in [LZ2001]_. For nonbipartite graph, the
    implementation is based on the following theorem:

    Given a nonbipartite graph `G` with a perfect matching `M`. The
    graph `G` is matching covered if and only if for each edge `uv`
    not in `M`, there exists an `M`-`alternating` odd length `uv`-path
    starting and ending with edges not in `M`.

    The time complexity may be dominated by the time needed to compute a
    maximum matching of the graph, in case a perfect matching is not
    provided. Also, note that for a disconnected or a trivial or a
    graph with a loop, a :class:`ValueError` is returned.

    INPUT:

    - ``matching`` -- (default: ``None``); a perfect matching of the
      graph, that can be given using any valid input format of
      :class:`~sage.graphs.graph.Graph`.

      If set to ``None``, a matching is computed using the other parameters.

    - ``algorithm`` -- string (default: ``'Edmonds'``); the algorithm to be
      used to compute a maximum matching of the graph among

      - ``'Edmonds'`` selects Edmonds' algorithm as implemented in NetworkX,

      - ``'LP'`` uses a Linear Program formulation of the matching problem.

      - ``'Micali-Vazirani'`` uses the Micali-Vazirani algorithm.

    - ``coNP_certificate`` -- boolean (default: ``False``); if set to
      ``True`` an edge of the graph, that does not participate in any
      perfect matching, is returned if `G` is not matching covered or
      otherwise ``None`` is returned.

    - ``solver`` -- string (default: ``None``); specify a Mixed Integer
      Linear Programming (MILP) solver to be used. If set to ``None``, the
      default one is used. For more information on MILP solvers and which
      default solver is used, see the method :meth:`solve
      <sage.numerical.mip.MixedIntegerLinearProgram.solve>` of the class
      :class:`MixedIntegerLinearProgram
      <sage.numerical.mip.MixedIntegerLinearProgram>`.

    - ``verbose`` -- integer (default: ``0``); sets the level of verbosity:
      set to 0 by default, which means quiet (only useful when ``algorithm
      == 'LP'``).

    - ``integrality_tolerance`` -- float; parameter for use with MILP
      solvers over an inexact base ring; see
      :meth:`MixedIntegerLinearProgram.get_values`.

    OUTPUT:

    - A boolean indicating whether the graph is matching covered or not.

    - If ``coNP_certificate`` is set to ``True``, an edge is returned in
      case the graph is not matching covered otherwise ``None`` is
      returned.

    EXAMPLES:

    The Petersen graph is matching covered::

        sage: G = graphs.PetersenGraph()
        sage: G.is_matching_covered()
        True

    A graph (without a self-loop) is matching covered if and only if the
    underlying simple graph is matching covered::

        sage: G = graphs.PetersenGraph()
        sage: G.allow_multiple_edges(True)
        sage: G.add_edge(0, 5)
        sage: G.is_matching_covered()
        True

    A corollary to Tutte's fundamental result [Tut1947]_, as a
    strengthening of Petersen's Theorem, states that every 2-connected
    cubic graph is matching covered::

        sage: G = Graph()
        sage: G.add_edges([
        ....:    (0, 1), (0, 2), (0, 3),
        ....:    (1, 2), (1, 4), (2, 4),
        ....:    (3, 5), (3, 6), (4, 7),
        ....:    (5, 6), (5, 7), (6, 7)
        ....: ])
        sage: G.vertex_connectivity()
        2
        sage: degree_sequence = G.degree_sequence()
        sage: min(degree_sequence) == max(degree_sequence) == 3
        True
        sage: G.is_matching_covered()
        True

    A connected bipartite graph `G[A, B]`, with `|A| = |B| \geq 2`, is
    matching covered if and only if `|N(X)| \geq |X| + 1`, for all
    `X \subset A` such that `1 \leq |X| \leq |A| - 1`. For instance,
    the Hexahedral graph is matching covered, but not the path graphs on
    even number of vertices, even though they have a perfect matching::

        sage: G = graphs.HexahedralGraph()
        sage: G.is_bipartite()
        True
        sage: G.is_matching_covered()
        True
        sage: P = graphs.PathGraph(10)
        sage: P.is_bipartite()
        True
        sage: M = Graph(P.matching())
        sage: set(P) == set(M)
        True
        sage: P.is_matching_covered()
        False

    A connected bipartite graph `G[A, B]` of order six or more is matching
    covered if and only if `G - a - b` has a perfect matching for some
    vertex `a` in `A` and some vertex `b` in `B`::

        sage: G = graphs.CircularLadderGraph(8)
        sage: G.is_bipartite()
        True
        sage: G.is_matching_covered()
        True
        sage: A, B = G.bipartite_sets()
        sage: # needs random
        sage: import random
        sage: a = random.choice(list(A))
        sage: b = random.choice(list(B))
        sage: G.delete_vertices([a, b])
        sage: M = Graph(G.matching())
        sage: set(M) == set(G)
        True
        sage: cycle1 = graphs.CycleGraph(4)
        sage: cycle2 = graphs.CycleGraph(6)
        sage: cycle2.relabel(lambda v: v + 4)
        sage: H = Graph()
        sage: H.add_edges(cycle1.edges() + cycle2.edges())
        sage: H.add_edge(3, 4)
        sage: H.is_bipartite()
        True
        sage: H.is_matching_covered()
        False
        sage: H.delete_vertices([3, 4])
        sage: N = Graph(H.matching())
        sage: set(N) == set(H)
        False

    One may specify a matching::

        sage: G = graphs.WheelGraph(20)
        sage: M = Graph(G.matching())
        sage: G.is_matching_covered(matching=M)
        True
        sage: J = graphs.CycleGraph(4)
        sage: J.add_edge(0, 2)
        sage: N = J.matching()
        sage: J.is_matching_covered(matching=N)
        False

    One may ask for a co-`\mathcal{NP}` certificate::

        sage: G = graphs.CompleteGraph(14)
        sage: G.is_matching_covered(coNP_certificate=True)
        (True, None)
        sage: H = graphs.PathGraph(20)
        sage: M = H.matching()
        sage: H.is_matching_covered(matching=M, coNP_certificate=True)
        (False, (2, 1, None))

    TESTS:

    If the graph is not connected::

        sage: cycle1 = graphs.CycleGraph(4)
        sage: cycle2 = graphs.CycleGraph(6)
        sage: cycle2.relabel(lambda v: v + 4)
        sage: G = Graph()
        sage: G.add_edges(cycle1.edges() + cycle2.edges())
        sage: len(G.connected_components(sort=False))
        2
        sage: G.is_matching_covered()
        Traceback (most recent call last):
        ...
        ValueError: the graph is not connected

    If the graph is trivial::

        sage: G = Graph()
        sage: G.is_matching_covered()
        Traceback (most recent call last):
        ...
        ValueError: the graph is trivial
        sage: H = graphs.CycleGraph(1)
        sage: H.is_matching_covered()
        Traceback (most recent call last):
        ...
        ValueError: the graph is trivial

    Providing with a wrong matching::

        sage: G = graphs.CompleteGraph(6)
        sage: M = Graph(G.matching())
        sage: M.add_edges([(0, 1), (0, 2)])
        sage: G.is_matching_covered(matching=M)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a matching
        sage: N = Graph(G.matching())
        sage: N.add_edge(6, 7)
        sage: G.is_matching_covered(matching=N)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a matching of the graph
        sage: J = Graph()
        sage: J.add_edges([(0, 1), (2, 3)])
        sage: G.is_matching_covered(matching=J)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a perfect matching of the graph

    Providing with a graph with a self-loop::

        sage: G = graphs.PetersenGraph()
        sage: G.allow_loops(True)
        sage: G.add_edge(0, 0)
        sage: G.is_matching_covered()
        Traceback (most recent call last):
        ...
        ValueError: This method is not known to work on graphs with loops.
        Perhaps this method can be updated to handle them, but in the meantime
        if you want to use it please disallow loops using allow_loops().

    REFERENCES:

    - [LM2024]_

    - [LZ2001]_

    - [Tut1947]_

    .. SEEALSO::
        :meth:`~sage.graphs.graph.Graph.is_factor_critical`,
        :meth:`~sage.graphs.graph.Graph.is_bicritical`

    AUTHORS:

    - Janmenjaya Panda (2024-06-23)
    """
    G._scream_if_not_simple(allow_multiple_edges=True)

    # The graph must be nontrivial
    if G.order() < 2:
        raise ValueError("the graph is trivial")

    # The graph must be connected
    if not G.is_connected():
        raise ValueError("the graph is not connected")

    # The graph must have an even order
    if G.order() % 2:
        return (False, next(G.edge_iterator())) if coNP_certificate else False

    # If the underlying simple graph is a complete graph of order two,
    # the graph is matching covered
    if G.order() == 2:
        return (True, None) if coNP_certificate else True

    from sage.graphs.graph import Graph
    if matching:
        # The input matching must be a valid perfect matching of the graph
        M = Graph(matching)

        if any(d != 1 for d in M.degree()):
            raise ValueError("the input is not a matching")

        if any(not G.has_edge(edge) for edge in M.edge_iterator()):
            raise ValueError("the input is not a matching of the graph")

        if (G.order() != M.order()) or (G.order() != 2*M.size()):
            raise ValueError("the input is not a perfect matching of the graph")
    else:
        # A maximum matching of the graph is computed
        M = Graph(G.matching(algorithm=algorithm, solver=solver, verbose=verbose,
                             integrality_tolerance=integrality_tolerance))

        # It must be a perfect matching
        if G.order() != M.order():
            return (False, next(M.edge_iterator())) if coNP_certificate else False

    # Biparite graph:
    #
    # Given a connected bipartite graph G[A, B] with a perfect matching M.
    # Construct a directed graph D from G such that V(D) := V(G) and
    # for each edge in G direct the corresponding edge from A to B in D,
    # if it is in M or otherwise direct it from B to A. The graph G is
    # matching covered if and only if D is strongly connected.

    if G.is_bipartite():
        A, _ = G.bipartite_sets()
        color = dict()

        for u in G:
            color[u] = 0 if u in A else 1

        from sage.graphs.digraph import DiGraph
        H = DiGraph()

        for u, v in G.edge_iterator(labels=False):
            if color[u]:
                u, v = v, u

            H.add_edge((u, v))
            if next(M.neighbor_iterator(u)) == v:
                H.add_edge((v, u))

        # Check if H is strongly connected using Kosaraju's algorithm
        def dfs(v, visited, neighbor_iterator):
            stack = [v]  # a stack of vertices

            while stack:
                v = stack.pop()
                visited.add(v)

                for u in neighbor_iterator(v):
                    if u not in visited:
                        stack.append(u)

        root = next(H.vertex_iterator())

        visited_in = set()
        dfs(root, visited_in, H.neighbor_in_iterator)

        visited_out = set()
        dfs(root, visited_out, H.neighbor_out_iterator)

        for edge in H.edge_iterator():
            u, v, _ = edge
            if (u not in visited_out) or (v not in visited_in):
                if not M.has_edge(edge):
                    return (False, edge) if coNP_certificate else False

        return (True, None) if coNP_certificate else True

    # Nonbipartite graph:
    #
    # Given a nonbipartite graph G with a perfect matching M. The graph G is
    # matching covered if and only if for each edge uv not in M, there exists
    # an M-alternating odd length uv-path starting and ending with edges not
    # in M.

    for u in G:
        v = next(M.neighbor_iterator(u))

        even = M_alternating_even_mark(G, u, M)

        for w in G.neighbor_iterator(v):
            if w != u and w not in even:
                return (False, (v, w)) if coNP_certificate else False

    return (True, None) if coNP_certificate else True


def matching(G, value_only=False, algorithm='Edmonds',
             use_edge_labels=False, solver=None, verbose=0,
             *, integrality_tolerance=1e-3):
    r"""
    Return a maximum weighted matching of the graph represented by the list
    of its edges.

    For more information, see the :wikipedia:`Matching_(graph_theory)`.

    Given a graph `G` such that each edge `e` has a weight `w_e`, a maximum
    matching is a subset `S` of the edges of `G` of maximum weight such that
    no two edges of `S` are incident with each other.

    As an optimization problem, it can be expressed as:

    .. MATH::

        \mbox{Maximize : }&\sum_{e\in G.edges()} w_e b_e\\
        \mbox{Such that : }&\forall v \in G,
        \sum_{(u,v)\in G.edges()} b_{(u,v)}\leq 1\\
        &\forall x\in G, b_x\mbox{ is a binary variable}

    INPUT:

    - ``value_only`` -- boolean (default: ``False``); when set to ``True``,
      only the cardinal (or the weight) of the matching is returned

    - ``algorithm`` -- string (default: ``'Edmonds'``)

      - ``'Edmonds'`` selects Edmonds' algorithm as implemented in NetworkX

      - ``'LP'`` uses a Linear Program formulation of the matching problem

      - ``'Micali-Vazirani'`` uses the Micali-Vazirani algorithm

    - ``use_edge_labels`` -- boolean (default: ``False``)

      - when set to ``True``, computes a weighted matching where each edge
        is weighted by its label (if an edge has no label, `1` is assumed)

      - when set to ``False``, each edge has weight `1`

    - ``solver`` -- string (default: ``None``); specifies a Mixed Integer
      Linear Programming (MILP) solver to be used. If set to ``None``, the
      default one is used. For more information on MILP solvers and which
      default solver is used, see the method :meth:`solve
      <sage.numerical.mip.MixedIntegerLinearProgram.solve>` of the class
      :class:`MixedIntegerLinearProgram
      <sage.numerical.mip.MixedIntegerLinearProgram>`.

    - ``verbose`` -- integer (default: 0); sets the level of verbosity:
      set to 0 by default, which means quiet (only useful when ``algorithm
      == "LP"``)

    - ``integrality_tolerance`` -- float; parameter for use with MILP
      solvers over an inexact base ring; see
      :meth:`MixedIntegerLinearProgram.get_values`.

    OUTPUT:

    - When ``value_only=False`` (default), this method returns an
      :class:`EdgesView` containing the edges of a maximum matching of `G`.

    - When ``value_only=True``, this method returns the sum of the
      weights (default: ``1``) of the edges of a maximum matching of `G`.
      The type of the output may vary according to the type of the edge
      labels and the algorithm used.

    ALGORITHM:

    The problem is solved using Edmond's algorithm implemented in NetworkX,
    or using Linear Programming or using the Micali-Vazirani algorithm
    depending on the value of ``algorithm``.

    EXAMPLES:

    Maximum matching in a Pappus Graph::

        sage: g = graphs.PappusGraph()
        sage: g.matching(value_only=True)                                            # needs sage.networkx
        9

    Same test with the Linear Program formulation::

        sage: g = graphs.PappusGraph()
        sage: g.matching(algorithm='LP', value_only=True)                            # needs sage.numerical.mip
        9

    .. PLOT::

        g = graphs.PappusGraph()
        sphinx_plot(g.plot(edge_colors={"red":g.matching()}))

    TESTS:

    When ``use_edge_labels`` is set to ``False``, with Edmonds' algorithm
    and LP formulation::

        sage: g = Graph([(0,1,0), (1,2,999), (2,3,-5)])
        sage: sorted(g.matching())                                                  # needs sage.networkx
        [(0, 1, 0), (2, 3, -5)]
        sage: sorted(g.matching(algorithm='LP'))                                    # needs sage.numerical.mip
        [(0, 1, 0), (2, 3, -5)]

    When ``use_edge_labels`` is set to ``True``, with Edmonds' algorithm and
    LP formulation::

        sage: g = Graph([(0,1,0), (1,2,999), (2,3,-5)])
        sage: g.matching(use_edge_labels=True)                                      # needs sage.networkx
        [(1, 2, 999)]
        sage: g.matching(algorithm='LP', use_edge_labels=True)                      # needs sage.numerical.mip
        [(1, 2, 999)]

    With loops and multiedges::

        sage: edge_list = [(0,0,5), (0,1,1), (0,2,2), (0,3,3), (1,2,6)
        ....: , (1,2,3), (1,3,3), (2,3,3)]
        sage: g = Graph(edge_list, loops=True, multiedges=True)
        sage: m = g.matching(use_edge_labels=True)                                  # needs sage.networkx
        sage: type(m)                                                               # needs sage.networkx
        <class 'sage.graphs.views.EdgesView'>
        sage: sorted(m)                                                             # needs sage.networkx
        [(0, 3, 3), (1, 2, 6)]

    Setting Algorithm to 'Micali-Vazirani'::

        sage: g = graphs.PetersenGraph()
        sage: m = g.matching(algorithm='Micali-Vazirani'); h = Graph(m)
        sage: # h is a 1-regular spanning subgraph of g
        sage: all(h.degree(v) == 1 for v in g) and set(h) == set(g) and \
        ....: h.size() == g.order() // 2 and h.is_subgraph(g, induced=False, up_to_isomorphism=False)
        True
        sage: g = graphs.CycleGraph(5)
        sage: g.matching(algorithm='Micali-Vazirani', value_only=True)
        2
        sage: g = graphs.SylvesterGraph()
        sage: m = g.matching(algorithm='Micali-Vazirani')
        sage: n = g.matching(algorithm='Edmonds')                                   # needs networkx
        sage: h, k = Graph(m), Graph(n)                                             # needs networkx
        sage: h.is_isomorphic(k)                                                    # needs networkx
        True

    TESTS:

    If ``algorithm`` is set to anything different from ``'Edmonds'``, ``'LP'``,
    or ``Micali-Vazirani`` an exception is raised::

        sage: g = graphs.PappusGraph()
        sage: g.matching(algorithm='somethingdifferent')
        Traceback (most recent call last):
        ...
        ValueError: algorithm must be set to one of the following: 'Edmonds,'
        'LP,' or 'Micali-Vazirani'

    Micali-Vazirani algorithm computes a maximum cardinality matching; the
    parameter ``use_edge_labels`` must be set to ``False``::

        sage: g = graphs.PappusGraph()
        sage: g.matching(algorithm='Micali-Vazirani', use_edge_labels=True)
        Traceback (most recent call last):
        ...
        ValueError: Micali-Vazirani algorithm does not support edge labels or weights
    """
    from sage.rings.real_mpfr import RR

    def weight(x):
        if x in RR:
            return x
        else:
            return 1

    W = {}
    L = {}
    for u, v, l in G.edge_iterator():
        if u is v:
            continue
        fuv = frozenset((u, v))
        if fuv not in L or (use_edge_labels and W[fuv] < weight(l)):
            L[fuv] = l
            if use_edge_labels:
                W[fuv] = weight(l)

    if algorithm == "Edmonds":
        import networkx
        g = networkx.Graph()
        if use_edge_labels:
            for (u, v), w in W.items():
                g.add_edge(u, v, weight=w)
        else:
            for u, v in L:
                g.add_edge(u, v)
        d = networkx.max_weight_matching(g)
        if value_only:
            if use_edge_labels:
                return sum(W[frozenset(e)] for e in d)
            return Integer(len(d))

        from sage.graphs.graph import Graph
        return EdgesView(Graph([(u, v, L[frozenset((u, v))]) for u, v in d],
                               format='list_of_edges'))

    elif algorithm == "LP":
        g = G
        from sage.numerical.mip import MixedIntegerLinearProgram
        # returns the weight of an edge considering it may not be
        # weighted ...
        p = MixedIntegerLinearProgram(maximization=True, solver=solver)
        b = p.new_variable(binary=True)
        if use_edge_labels:
            p.set_objective(p.sum(w * b[fe] for fe, w in W.items()))
        else:
            p.set_objective(p.sum(b[fe] for fe in L))
        # for any vertex v, there is at most one edge incident to v in
        # the maximum matching
        for v in g:
            p.add_constraint(p.sum(b[frozenset(e)] for e in G.edge_iterator(vertices=[v], labels=False)
                                   if e[0] != e[1]), max=1)

        p.solve(log=verbose)
        b = p.get_values(b, convert=bool, tolerance=integrality_tolerance)
        if value_only:
            if use_edge_labels:
                return sum(w for fe, w in W.items() if b[fe])
            return Integer(sum(1 for fe in L if b[fe]))

        from sage.graphs.graph import Graph
        return EdgesView(Graph([(u, v, L[frozenset((u, v))])
                                for u, v in L if b[frozenset((u, v))]],
                               format='list_of_edges'))

    elif algorithm == "Micali-Vazirani":
        if use_edge_labels:
            raise ValueError("Micali-Vazirani algorithm does not support edge labels or weights")

        micali_vazirani_matching = MicaliVaziraniMatching(G.to_simple())
        M = micali_vazirani_matching.get_matching()

        return len(M) if value_only else M

    else:
        raise ValueError('algorithm must be set to one of the following: '
                     '\'Edmonds,\' \'LP,\' or \'Micali-Vazirani\'')


def perfect_matchings(G, labels=False):
    r"""
    Return an iterator over all perfect matchings of the graph.

    ALGORITHM:

    Choose a vertex `v`, then recurse through all edges incident to `v`,
    removing one edge at a time whenever an edge is added to a matching.

    INPUT:

    - ``labels`` -- boolean (default: ``False``); when ``True``, the edges
      in each perfect matching are triples (containing the label as the
      third element), otherwise the edges are pairs.

    .. SEEALSO::

        :meth:`matching`

    EXAMPLES::

        sage: G=graphs.GridGraph([2,3])
        sage: for m in G.perfect_matchings():
        ....:     print(sorted(m))
        [((0, 0), (0, 1)), ((0, 2), (1, 2)), ((1, 0), (1, 1))]
        [((0, 0), (1, 0)), ((0, 1), (0, 2)), ((1, 1), (1, 2))]
        [((0, 0), (1, 0)), ((0, 1), (1, 1)), ((0, 2), (1, 2))]

        sage: G = graphs.CompleteGraph(4)
        sage: for m in G.perfect_matchings(labels=True):
        ....:     print(sorted(m))
        [(0, 1, None), (2, 3, None)]
        [(0, 2, None), (1, 3, None)]
        [(0, 3, None), (1, 2, None)]

        sage: G = Graph([[1,-1,'a'], [2,-2, 'b'], [1,-2,'x'], [2,-1,'y']])
        sage: sorted(sorted(m) for m in G.perfect_matchings(labels=True))
        [[(-2, 1, 'x'), (-1, 2, 'y')], [(-2, 2, 'b'), (-1, 1, 'a')]]

        sage: G = graphs.CompleteGraph(8)
        sage: mpc = G.matching_polynomial().coefficients(sparse=False)[0]           # needs sage.libs.flint
        sage: len(list(G.perfect_matchings())) == mpc                               # needs sage.libs.flint
        True

        sage: G = graphs.PetersenGraph().copy(immutable=True)
        sage: [sorted(m) for m in G.perfect_matchings()]
        [[(0, 1), (2, 3), (4, 9), (5, 7), (6, 8)],
            [(0, 1), (2, 7), (3, 4), (5, 8), (6, 9)],
            [(0, 4), (1, 2), (3, 8), (5, 7), (6, 9)],
            [(0, 4), (1, 6), (2, 3), (5, 8), (7, 9)],
            [(0, 5), (1, 2), (3, 4), (6, 8), (7, 9)],
            [(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]]

        sage: list(Graph().perfect_matchings())
        [[]]

        sage: G = graphs.CompleteGraph(5)
        sage: list(G.perfect_matchings())
        []
    """
    if not G:
        yield []
        return
    if G.order() % 2 or any(len(cc) % 2 for cc in G.connected_components(sort=False)):
        return

    def rec(G):
        """
        Iterator over all perfect matchings of a simple graph `G`.
        """
        if not G:
            yield []
            return
        if G.order() % 2 == 0:
            v = next(G.vertex_iterator())
            Nv = list(G.neighbor_iterator(v))
            G.delete_vertex(v)
            for u in Nv:
                Nu = list(G.neighbor_iterator(u))
                G.delete_vertex(u)
                for partial_matching in rec(G):
                    partial_matching.append((u, v))
                    yield partial_matching
                G.add_vertex(u)
                G.add_edges((u, nu) for nu in Nu)
            G.add_vertex(v)
            G.add_edges((v, nv) for nv in Nv)

    # We create a mutable copy of the graph and remove its loops, if any
    G_copy = G.copy(immutable=False)
    G_copy.allow_loops(False)

    # We create a mapping from frozen unlabeled edges to (labeled) edges.
    # This ease for instance the manipulation of multiedges (if any)
    edges = {}
    for e in G_copy.edges(sort=False, labels=labels):
        f = frozenset(e[:2])
        if f in edges:
            edges[f].append(e)
        else:
            edges[f] = [e]

    # We now get rid of multiple edges, if any
    G_copy.allow_multiple_edges(False)

    # For each unlabeled matching, we yield all its possible labelings
    for m in rec(G_copy):
        yield from itertools.product(*[edges[frozenset(e)] for e in m])


def M_alternating_even_mark(G, vertex, matching):
    r"""
    Return the vertices reachable from ``vertex`` via an even alternating path
    starting with a non-matching edge.

    This method implements the algorithm proposed in [LR2004]_. Note that
    the complexity of the algorithm is linear in number of edges.

    INPUT:

    - ``vertex`` -- a vertex of the graph

    - ``matching`` -- a matching of the graph; it can be given using any
      valid input format of :class:`~sage.graphs.graph.Graph`

    OUTPUT:

    - ``even`` -- the set of vertices each of which is reachable from the
      provided vertex through a path starting with an edge not in the
      matching and ending with an edge in the matching; note that a note that a
      :class:`ValueError` is returned if the graph is not simple

    EXAMPLES:

    Show the list of required vertices for a graph `G` with a matching `M`
    for a vertex `u`::

        sage: G = graphs.CycleGraph(3)
        sage: M = G.matching()
        sage: M
        [(0, 2, None)]
        sage: from sage.graphs.matching import M_alternating_even_mark
        sage: S0 = M_alternating_even_mark(G, 0, M)
        sage: S0
        {0}
        sage: S1 = M_alternating_even_mark(G, 1, M)
        sage: S1
        {0, 1, 2}

    The result is equivalent for the underlying simple graph of the provided
    graph, if the other parameters provided are the same::

        sage: G = graphs.CompleteBipartiteGraph(3, 3)
        sage: G.allow_multiple_edges(True)
        sage: G.add_edge(0, 3)
        sage: M = G.matching()
        sage: u = 0
        sage: from sage.graphs.matching import M_alternating_even_mark
        sage: S = M_alternating_even_mark(G, u, M)
        sage: S
        {0, 1, 2}
        sage: T = M_alternating_even_mark(G.to_simple(), u, M)
        sage: T
        {0, 1, 2}

    For a factor critical graph `G` (for instance, a wheel graph of an odd
    order) with a near perfect matching `M` and `u` being the (unique)
    `M`-exposed vertex, each vertex in `G` is reachable from `u` through an
    even length `M`-alternating path as described above::

        sage: G = graphs.WheelGraph(11)
        sage: M = Graph(G.matching())
        sage: G.is_factor_critical(M)
        True
        sage: for v in G:
        ....:     if v not in M:
        ....:          break
        ....:
        sage: from sage.graphs.matching import M_alternating_even_mark
        sage: S = M_alternating_even_mark(G, v, M)
        sage: S == set(G)
        True

    For a matching covered graph `G` (for instance, `K_4 \odot K_{3,3}`) with a
    perfect matching `M` and for some vertex `u` with `v` being its `M`-matched
    neighbor, each neighbor of `v` is reachable from `u` through an even length
    `M`-alternating path as described above::

        sage: G = Graph()
        sage: G.add_edges([
        ....:    (0, 2), (0, 3), (0, 4), (1, 2),
        ....:    (1, 3), (1, 4), (2, 5), (3, 6),
        ....:    (4, 7), (5, 6), (5, 7), (6, 7)
        ....: ])
        sage: M = Graph(G.matching())
        sage: G.is_matching_covered(M)
        True
        sage: u = 0
        sage: v = next(M.neighbor_iterator(u))
        sage: from sage.graphs.matching import M_alternating_even_mark
        sage: S = M_alternating_even_mark(G, u, M)
        sage: (set(G.neighbor_iterator(v))).issubset(S)
        True

    For a bicritical graph `G` (for instance, the Petersen graph) with a
    perfect matching `M` and for some vertex `u` with its `M`-matched neighbor
    being `v`, each vertex of the graph distinct from `v` is reachable from `u`
    through an even length `M`-alternating path as described above::

        sage: G = graphs.PetersenGraph()
        sage: M = Graph(G.matching())
        sage: G.is_bicritical(M)
        True
        sage: import random
        sage: u = random.choice(list(G))                                            # needs random
        sage: v = next(M.neighbor_iterator(u))
        sage: from sage.graphs.matching import M_alternating_even_mark
        sage: S = M_alternating_even_mark(G, u, M)
        sage: S == (set(G) - {v})
        True

    TESTS:

    Giving a wrong vertex::

        sage: G = graphs.HexahedralGraph()
        sage: M = G.matching()
        sage: u = G.order()
        sage: from sage.graphs.matching import M_alternating_even_mark
        sage: S = M_alternating_even_mark(G, u, M)
        Traceback (most recent call last):
        ...
        ValueError: '8' is not a vertex of the graph

    Giving a wrong matching::

        sage: from sage.graphs.matching import M_alternating_even_mark
        sage: G = graphs.CompleteGraph(6)
        sage: M = [(0, 1), (0, 2)]
        sage: u = 0
        sage: S = M_alternating_even_mark(G, u, M)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a matching
        sage: G = graphs.CompleteBipartiteGraph(3, 3)
        sage: M = [(2*i, 2*i + 1) for i in range(4)]
        sage: u = 0
        sage: S = M_alternating_even_mark(G, u, M)
        Traceback (most recent call last):
        ...
        ValueError: the input is not a matching of the graph

    REFERENCES:

    - [LR2004]_

    .. SEEALSO::
        :meth:`~sage.graphs.graph.Graph.is_factor_critical`,
        :meth:`~sage.graphs.graph.Graph.is_matching_covered`,
        :meth:`~sage.graphs.graph.Graph.is_bicritical`

    AUTHORS:

    - Janmenjaya Panda (2024-06-17)
    """
    # The input vertex must be a valid vertex of the graph
    if vertex not in G:
        raise ValueError("'{}' is not a vertex of the graph".format(vertex))

    # The result is equivalent for the underlying simple graph of the provided
    # graph. So, the underlying simple graph is considered for implementational
    # simplicity.
    G_simple = G.to_simple()

    # The input matching must be a valid matching of the graph
    from sage.graphs.graph import Graph
    M = Graph(matching)
    if any(d != 1 for d in M.degree()):
        raise ValueError("the input is not a matching")

    if any(not G.has_edge(edge) for edge in M.edge_iterator()):
        raise ValueError("the input is not a matching of the graph")

    # Build an M-alternating tree T rooted at vertex
    from queue import Queue

    q = Queue()
    q.put(vertex)

    even = set([vertex])
    odd = set()
    predecessor = {vertex: vertex}
    rank = {vertex: 0}

    if vertex in M:
        u = next(M.neighbor_iterator(vertex))
        predecessor[u] = None
        rank[u] = -1
        odd.add(u)

    while not q.empty():
        x = q.get()
        for y in G_simple.neighbor_iterator(x):
            if y in odd:
                continue
            elif y in even:
                # Search t := LCA(x, y)
                ancestor_x = [x]
                ancestor_y = [y]

                # Loop over until the nearest common ancestor of x and y is reached
                while ancestor_x[-1] != ancestor_y[-1]:
                    if rank[ancestor_x[-1]] > rank[ancestor_y[-1]]:
                        ancestor_x.append(predecessor[ancestor_x[-1]])

                    elif rank[ancestor_x[-1]] < rank[ancestor_y[-1]]:
                        ancestor_y.append(predecessor[ancestor_y[-1]])

                    else:
                        ancestor_x.append(predecessor[ancestor_x[-1]])
                        ancestor_y.append(predecessor[ancestor_y[-1]])

                lcs = ancestor_x.pop()
                ancestor_y.pop()
                # Set t as pred of all vertices of the chains and add
                # vertices marked odd to the queue
                next_rank_to_lcs_rank = rank[lcs] + 1

                for a in itertools.chain(ancestor_x, ancestor_y):
                    predecessor[a] = lcs
                    rank[a] = next_rank_to_lcs_rank

                    if a in odd:
                        even.add(a)
                        odd.discard(a)
                        q.put(a)

            elif y in M:
                # y has not been visited yet
                z = next(M.neighbor_iterator(y))
                odd.add(y)
                even.add(z)
                q.put(z)

                predecessor[y] = x
                predecessor[z] = y

                rank[y] = rank[x] + 1
                rank[z] = rank[y] + 1

    return even

class MicaliVaziraniMatching:
    r"""
    Class for computing maximum cardinality matching in a simple undirected
    unweighted graph using the Micali-Vazirani algorithm.
    """
    from dataclasses import dataclass
    from sage.graphs.graph import Graph
    from typing import Any, List, Tuple, Set, Dict, Optional

    Edge = Tuple[int, int, Any]

    @dataclass
    class Petal:
        base: int
        peaks: Tuple[int, int]

    def __init__(self, G: Graph) -> None:
        if G.has_loops() or G.has_multiple_edges():
            raise ValueError("Micali-Vazirani algorithm is only applicable to simple undirected graphs")

        # ******************************
        # Set up global state containers
        # ******************************
        self.G = G.copy(immutable=False)
        self.N = G.order()

        # relabel vertices of G to 0..N1
        for vertex in self.G:
            if not self.G.degree(vertex):
                self.G.delete_vertex(vertex)

        # indexing the vertices
        self.vertex_to_index = self.G.relabel(inplace=True, return_map=True)
        self.index_to_vertex = [None] * self.N
        for vertex, index in self.vertex_to_index.items():
            self.index_to_vertex[index] = vertex

        self.tenacity_bridges_map: List[List[int]] = [[] for _ in range(2 * self.N + 2)]
        self.deletion_phase: List[int] = [-1] * self.N
        self.visit_mark: List[Any] = [None] * self.N
        self.vertex_petal_map: List[Any] = [None] * self.N
        self.vertex_bud_map: List[int] = list(range(self.N))
        self.level: List[List[Any]] = [[0, float('inf')] for _ in range(self.N)]
        self.min_level: List[int] = [0] * self.N
        self.max_level: List[Any] = [float('inf')] * self.N
        self.predecessor: List[List[int]] = [[] for _ in range(self.N)]
        self.successor: List[List[int]] = [[] for _ in range(self.N)]
        self.color: List[int] = [None] * self.N
        self.search_level_vertices: List[int] = list(range(self.N))
        self.edge_scanned: Dict[int, int] = {self.edge_to_index(u, v): -1 for (u, v, _) in self.G.edge_iterator()}
        self.prop_edges: Set[int] = set()

        self.M = Graph()
        self.M.add_vertices(self.G)
        self.phase_index = 0
        self.num_augmentations = 0
        self.INFINITY = float('inf')

    # indexing the edges
    def edge_to_index(self, i: int, j: int) -> int:
        if i > j:
            i, j = j, i

        # A[i] = (i * (2*N - i - 1)) // 2
        return (i * (2*self.N - i - 1)) // 2 + (j - i - 1)

    def index_to_edge(self, k: int) -> Edge:
        import math
        i = int(((2*self.N - 1) - math.sqrt((2*self.N - 1)**2 - 8*k)) // 2)
        a_i = i * (2*self.N - i - 1) // 2
        j = k - a_i + i + 1
        return (i, j)

    # *************************************
    # Greedy initial maximal matching (so as to reduce the total number of phases)
    # *************************************
    def compute_initial_maximal_matching(self) -> EdgesView:
        """
        Compute a greedy maximal matching to seed the main algorithm.

        This routine builds an initial matching by repeatedly selecting a vertex of
        minimum (positive) degree, matching it with a neighbour of minimum degree,
        and removing that vertex, its matched neighbour from the graph.  The goal
        is to reduce the number of augmenting phases required by the main algorithm.
        """
        # Make a copy J of G for the greedy matching process
        J: Graph = self.G.copy(immutable=False)

        # Get the degree sequence of J
        degree_sequence = J.degree_sequence()
        maximum_degree = max(degree_sequence)
        minimum_degree = min(degree_sequence)

        # Create a list of buckets, where bucket[i] contains the set of vertices of degree i
        degree: List[int] = [J.degree(v) for v in range(self.N)]

        # buckets[d] contains the set of vertices currently having degree d in J
        buckets: List[set] = [set() for _ in range(maximum_degree + 1)]
        for v in J:
            buckets[degree[v]].add(v)

        # Main loop: continue while there is a non-empty bucket of degrees
        while minimum_degree < len(buckets):

            # If J has at most one vertex, exit the loop
            if J.order() <= 1:
                break

            # If there are no vertices with the current minimum degree, advance
            if not buckets[minimum_degree]:
                minimum_degree += 1
                continue

            # Pop a vertex u of minimum degree
            u = buckets[minimum_degree].pop()

            # Choose the neighbour v of u with minimum degree
            neighbours = list(J.neighbors(u))

            if not neighbours:
                degree[u] -= 1

                # Remove isolated vertex and continue
                J.delete_vertex(u)
                continue

            # choose neighbour v with minimum degree (ties broken by smallest index)
            v = min(neighbours, key=lambda x: degree[x])

            # Add the edge (u, v) to the matching M with its label
            self.M.add_edge(u, v, J.edge_label(u, v))

            # Update the degree of neighbours and relocate them to new buckets
            # the degrees will decrease by at most 2 after deletion
            # since J is free of multiple edges

            for x in [u, v]:
                for w in J.neighbors(x):
                    if w in [u, v]:
                        continue

                    buckets[degree[w]].discard(w)
                    degree[w] -= 1
                    buckets[degree[w]].add(w)

            # Remove u and v from the graph J
            J.delete_vertices([u, v])

            # Remove these vertices from the bucket lists and update the degree in degree list
            for vertex in [u, v]:
                buckets[degree[vertex]].discard(vertex)
                degree[vertex] = -1

            # Reset minimum_degree to find the next smallest bucket
            minimum_degree = 0

    # ******************************
    # Start a new phase
    # ******************************
    def start_new_phase(self) -> None:
        self.search_level_vertices = []

        for u in self.G:
            # A vertex is considered matched if it is incident to an edge in the current matching M.
            # Checking `u in M` only tests whether u is a vertex of M, so use degree instead.
            if self.M.degree(u) > 0:
                # Matched vertices start with infinite levels
                self.min_level[u] = self.INFINITY
                self.max_level[u] = self.INFINITY
                self.level[u] = [self.INFINITY, self.INFINITY]

            else:
                # Unmatched vertices start at level 0 and are candidates for search
                self.search_level_vertices.append(u)
                self.min_level[u] = 0
                self.max_level[u] = self.INFINITY
                self.level[u] = [0, self.INFINITY]

            self.predecessor[u] = []
            self.successor[u] = []
            self.vertex_petal_map[u] = None
            self.vertex_bud_map[u] = u
            self.color[u] = None
            self.visit_mark[u] = None

        for u, v in self.G.edge_iterator(labels=False):
            edge_index = self.edge_to_index(u, v)
            self.prop_edges.discard(edge_index)
            self.edge_scanned[edge_index] = -1

        for index in range(1, int(2*self.G.order()+2)):
            self.tenacity_bridges_map[index] = []

    # ******************************
    # Primary Subroutine: Find min_level of vertices
    # ******************************
    def MIN(self, search_level: int) -> bool:
        next_search_level_vertices = []
        parity = search_level % 2

        if not self.search_level_vertices or search_level > self.G.order():
            return True

        for u in self.search_level_vertices:
            if self.level[u][parity] != search_level and self.level[u][parity] < self.INFINITY:
                next_search_level_vertices.append(u)
                continue

            if self.deletion_phase[u] == self.phase_index:
                continue

            for v in self.G.neighbor_iterator(u):
                edge_index = self.edge_to_index(u, v)
                l = self.G.edge_label(u, v)

                if self.edge_scanned[edge_index] != self.phase_index and self.M.has_edge(u, v, l) == parity and self.deletion_phase[v] != self.phase_index:
                    self.edge_scanned[edge_index] = self.phase_index

                    if self.min_level[v] > search_level:
                        self.min_level[v] = search_level + 1
                        self.level[v][1 - parity] = search_level + 1
                        next_search_level_vertices.append(v)
                        self.predecessor[v].append(u)
                        self.successor[u].append(v)
                        self.prop_edges.add(edge_index)

                    else:
                        tenacity = self.level[u][parity] + self.level[v][parity] + 1

                        # In the case where tenacity is defined and thus we know which level the bridge will be processed
                        if tenacity < self.INFINITY:
                            if tenacity >= len(self.tenacity_bridges_map):
                                self.tenacity_bridges_map.extend([] for _ in range(tenacity - len(self.tenacity_bridges_map) + 1))
                            self.tenacity_bridges_map[tenacity].append(edge_index)

                        # The case where tenacity is not yet known (possibly due to the even/ odd level of the blossom not yet labeled
                        else:
                            self.prop_edges.discard(edge_index)

        self.search_level_vertices = next_search_level_vertices
        return False

    # ******************************
    # Primary Subroutine: Find max_level of vertices
    # ******************************
    def MAX(self, search_level: int) -> bool:
        is_augmented = False

        for edge_index in self.tenacity_bridges_map[2 * search_level + 1]:
            u, v = self.index_to_edge(edge_index)
            l = self.G.edge_label(u, v)
            if self.deletion_phase[u] == self.phase_index or self.deletion_phase[v] == self.phase_index:
                continue

            left_support, right_support, bottleneck, encountered_deleted_vertex = self.DDFS(u, v)

            # if the bridge has been augmented
            if bottleneck is None:
                if not encountered_deleted_vertex:
                    augmentation_success = self.augment(left_support, right_support, (u, v, l))
                    if augmentation_success:
                        is_augmented = True
                        if self.M.size() == self.G.order() // 2:
                            return is_augmented

            else:
                if not encountered_deleted_vertex:
                    self.form_blossom(left_support, right_support, bottleneck, (u, v, l))
                    self.label_max(left_support, search_level)
                    self.label_max(right_support, search_level)

        if is_augmented:
            self.num_augmentations += 1
            is_augmented = False

        return is_augmented

    # After identifying support, we assign the vertex its max level label.
    # Note: This step is skipped during augmentation, as max levels are reset regardless.
    # ******************************
    # Label vertices after forming a blossom
    # ******************************
    def label_max(self, support: List[int], search_level: int) -> None:
        next_search_level_vertices: List[int] = []
        for vertex in support:
            self.max_level[vertex] = 2 * search_level + 1 - self.min_level[vertex]
            level_parity = self.max_level[vertex] % 2

            # Record the actual max level on the corresponding parity slot
            self.level[vertex][level_parity] = self.max_level[vertex]
            next_search_level_vertices.append(vertex)

            if not level_parity:
                for neighbor in self.G.neighbor_iterator(vertex):
                    edge_index = self.edge_to_index(vertex, neighbor)

                    # In the case were the tenacity of a tenacity_bridges_map was not yet found
                    if edge_index not in self.prop_edges:
                        self.tenacity_bridges_map[self.max_level[vertex] + self.level[neighbor][0] + 1].append(edge_index)

        self.search_level_vertices += next_search_level_vertices

    # ******************************
    # Double DFS to locate augmenting paths
    # ******************************
    def DDFS(self, source_red_vertex: int, source_green_vertex: int) -> Tuple[List[int], List[int], Optional[int], bool]:
        encountered_deleted_vertex = False

        # Set the starting point for each of red and green DFS's
        red_stack, green_stack = [], []  # Stack saves previously traversed vertices
        red_vertex, green_vertex = self.get_bud(source_red_vertex), self.get_bud(source_green_vertex)  # Set the initial point for both DFS's

        red_predecessors, green_predecessors = \
            self.predecessor[red_vertex][:], self.predecessor[green_vertex][:]  # Copy predecessor list over for the current vertex
        red_support, green_support = [red_vertex], [green_vertex]  # the lists holding the support of the current bridge

        # Following is used to save the data for DFS's for when they backtrack in the case a bottleneck is reached
        previous_red_support, previous_green_support = [red_vertex], [green_vertex]

        # Boolean variables are initiated
        no_augmentation_found = False if not self.min_level[red_vertex] and not self.min_level[green_vertex] else True
        collision = True if red_vertex == green_vertex else False

        # Returns nothing if there is no support for the petal
        if collision and not no_augmentation_found:
            return [], [], red_vertex, encountered_deleted_vertex

        # Label is used to track if vertices have been visit_mark in the current DDFS
        label = (source_red_vertex, source_green_vertex)
        self.visit_mark[red_vertex], self.visit_mark[green_vertex] = label, label

        # DDFS continues to run while an augmenting path still isn't found
        while no_augmentation_found:
            # Checks for when the two DFS's land on the same vertex
            if collision:
                # The the levels of the vertices are the same, we reverse the green DFS
                if self.min_level[red_vertex] == self.min_level[green_vertex]:
                    previous_green_support = green_support[:]
                    green_vertex, green_predecessors, reverse_check = self.reverse_DFS(green_vertex, green_predecessors, green_stack, green_support)

                    if reverse_check:
                        previous_red_support, red_bottleneck = red_support[:], red_vertex
                        red_vertex, red_predecessors, reverse_check = self.reverse_DFS(red_vertex, red_predecessors, red_stack, red_support)

                elif self.min_level[red_vertex] > self.min_level[green_vertex]:
                    red_vertex, red_predecessors, collision = self.reverse_DFS(red_vertex, red_predecessors, red_stack, red_support)

                elif self.min_level[red_vertex] < self.min_level[green_vertex]:
                    green_vertex, green_predecessors, collision = self.reverse_DFS(green_vertex, green_predecessors, green_stack, green_support)

                if red_vertex == green_vertex:
                    previous_red_support.pop()
                    green_support.pop()
                    return previous_red_support, green_support, red_vertex, encountered_deleted_vertex

                collision = False

            # Case where red DFS advances in search
            elif self.min_level[red_vertex] >= self.min_level[green_vertex]:

                # Advance the red DFS, will reverse if no vertices to travel to
                red_vertex, red_predecessors, collision = self.advance_DFS(red_vertex, red_predecessors, red_stack, red_support, label)

                # If stack is cleared and no vertices left to explore, bottleneck is found
                if not red_stack and not red_predecessors:
                    previous_red_support.pop()
                    green_support.pop()
                    return previous_red_support, green_support, green_vertex, encountered_deleted_vertex

            # Case where green DFS advances in search
            else:
                # Advance the green DFS, will reverse if no vertices to travel to
                green_vertex, green_predecessors, collision = self.advance_DFS(green_vertex, green_predecessors, green_stack, green_support, label)

                # If stack is clearned and no vertices left to explore, reverse red DFS
                if not green_stack and not green_predecessors:
                    green_support = previous_green_support
                    previous_green_support, green_vertex, green_predecessors = [green_vertex], red_vertex, red_predecessors[:]
                    previous_red_support, red_bottleneck = red_support[:], red_vertex
                    red_vertex, red_predecessors, reverse_check = self.reverse_DFS(red_vertex, red_predecessors, red_stack, red_support)

                    if reverse_check:
                        previous_red_support.pop()
                        green_support.pop()
                        return previous_red_support, green_support, red_bottleneck, encountered_deleted_vertex

            # Checks if vertex was removed in previous augmentation during current search_level
            if self.deletion_phase[red_vertex] == self.phase_index or self.deletion_phase[green_vertex] == self.phase_index:
                encountered_deleted_vertex = True

            # Checks if augmenting path has been found
            if not self.min_level[red_vertex] and not self.min_level[green_vertex] and red_vertex != green_vertex:
                no_augmentation_found = False

        return red_support, green_support, None, encountered_deleted_vertex

    # ******************************
    # Auxiliary Subroutine: advance DFS along predecessors
    # ******************************
    def advance_DFS(self, vertex: int, predecessor_list: List[int], stack: List[Tuple[int, List[int]]], support: List[int], label: Tuple[int, int]) -> Tuple[int, List[int], bool]:
        reverse_check = False
        if predecessor_list:
            next_vertex = self.get_bud(predecessor_list.pop())

            # Save the previous vertex with it's predecessor list to the stack
            stack.append((vertex, predecessor_list))

            # Add next vertex to support
            support.append(next_vertex)
            predecessor_list = self.predecessor[next_vertex][:]

            if self.visit_mark[next_vertex] == label:
                return next_vertex, predecessor_list, True
            self.visit_mark[next_vertex] = label

        # If next vertex not found reverse path
        else:
            next_vertex, predecessor_list, reverse_check = self.reverse_DFS(vertex, predecessor_list, stack, support)
        return next_vertex, predecessor_list, reverse_check

    # ******************************
    # Auxiliary Subroutine: backtrack in DFS stack
    # ******************************
    def reverse_DFS(self, vertex: int, predecessor_list: List[int], stack: List[Tuple[int, List[int]]], support: List[int]) -> Tuple[int, List[int], bool]:
        failure = False
        if stack:
            previous_vertex = stack.pop()
            vertex = previous_vertex[0]
            predecessor_list = previous_vertex[1]
            support.pop()
        else:
            failure = True
        return vertex, predecessor_list, failure

    # Each vertex can only belong to one petal
    # The bud cannot be part of the petal
    # Each vertex in the petal points to the bud

    # ******************************
    # Contract a blossom (petal)
    # ******************************
    def form_blossom(self, left_support: List[int], right_support: List[int], bud: int, bridge: Edge) -> None:
        """
        Create a new blossom centered at 'bud' with supports from both sides.
        """
        petal = self.Petal(base=bud, peaks=(bridge[0], bridge[1]))
        self.form_petal(left_support, bud, petal, 0)
        self.form_petal(right_support, bud, petal, 1)

    def form_petal(self, support: List[int], bud: int, petal: Petal, direction: int) -> None:
        """
        Assign each vertex in support to the given petal and direction.
        """
        for vertex in support:
            self.vertex_bud_map[vertex] = get_bud(bud)
            self.vertex_petal_map[vertex] = petal
            self.color[vertex] = direction

    # ******************************
    # Path compression: find the bud of a vertex
    # ******************************
    def get_bud(self, vertex: int) -> int:
        if vertex != self.vertex_bud_map[vertex]:
            self.vertex_bud_map[vertex] = self.get_bud(self.vertex_bud_map[vertex])
        return self.vertex_bud_map[vertex]

    # ******************************
    # Unfold a blossom (petal)
    # ******************************
    def unfold_petal(self, vertex: int, target: int) -> List[int]:
        """
        Unfolds a petal to get the path from the vertex that is part of the petal to the bud
        """
        path = list()
        petal = self.vertex_petal_map[vertex]
        bud = petal.base
        if self.max_level[vertex] % 2:
            path = self.unfold_path_in_petal(vertex, bud, petal)
        else:
            red_vertex = petal.peaks[0]
            green_vertex = petal.peaks[1]
            if not self.color[vertex]:
                left_path = self.unfold_path_in_petal(red_vertex, vertex, petal)
                right_path = self.unfold_path_in_petal(green_vertex, bud, petal)
                if left_path and right_path:
                    left_path.reverse()
                    path = left_path + right_path
                else:
                    return []
            elif self.color[vertex]:
                left_path = self.unfold_path_in_petal(red_vertex, bud, petal)
                right_path = self.unfold_path_in_petal(green_vertex, vertex, petal)
                if left_path and right_path:
                    right_path.reverse()
                    path = right_path + left_path
                else:
                    return []
        if bud == target:
            return path
        else:
            path.pop()
            petal_path = self.unfold_petal(bud, target)
            return path + petal_path

    def unfold_path_in_petal(self, start_vertex: int, end_vertex: int, petal: Petal) -> List[int]:
        if start_vertex == end_vertex:
            return [start_vertex]
        if self.vertex_petal_map[start_vertex] != petal:
            new_target = self.vertex_petal_map[start_vertex].base
            path = self.unfold_petal(start_vertex, new_target)
            current_vertex = new_target
        else:
            path = [start_vertex]
            current_vertex = start_vertex
        while current_vertex != end_vertex:
            previous_vertex = current_vertex
            predecessor_list = self.predecessor[current_vertex][:]
            new_petal = None
            next_petal_vertex = None
            wrong_petal_vertex = None
            for vertex in predecessor_list:
                if self.vertex_petal_map[vertex] is not None:
                    if vertex == end_vertex:
                        current_vertex = vertex
                        path.append(end_vertex)
                        break
                    elif self.vertex_petal_map[vertex] == petal and self.color[current_vertex] == color[vertex]:
                        next_petal_vertex = vertex
                    elif self.vertex_petal_map[vertex] == petal and self.color[current_vertex] != color[vertex]:
                        wrong_petal_vertex = vertex
                    else:
                        new_petal = vertex
                else:
                    if vertex == petal.base:
                        current_vertex = vertex
                        path.append(end_vertex)
                        break

            if previous_vertex == current_vertex:
                if next_petal_vertex is not None:
                    current_vertex = next_petal_vertex
                    path.append(current_vertex)

                elif wrong_petal_vertex is not None:
                    current_vertex = vertex
                    if self.vertex_petal_map[vertex] != petal and self.vertex_petal_map[vertex] is not None:
                        petal_path = self.unfold_petal(current_vertex, self.vertex_petal_map[vertex].base)
                        path += petal_path
                        current_vertex = path[-1]
                    else:
                        path.append(current_vertex)
                elif new_petal is None:
                    return []

                else:
                    if not self.M.has_edge(current_vertex, new_petal, self.G.edge_label(current_vertex, new_petal)):
                        path_addition = self.unfold_petal(new_petal, self.vertex_petal_map[new_petal].base)
                        if not path_addition:
                            return []

                        path += path_addition
                        current_vertex = self.vertex_petal_map[new_petal].base
                        while self.vertex_petal_map[current_vertex] != petal and current_vertex != end_vertex:
                            # digging deeper into the petal
                            path.pop()
                            if self.vertex_petal_map[current_vertex]:
                                path += self.unfold_petal(current_vertex, self.vertex_petal_map[current_vertex].base)
                                current_vertex = self.vertex_petal_map[current_vertex].base
                            else:
                                # bud failure
                                return []
                    else:
                        path += self.unfold_path_in_petal(new_petal, self.vertex_petal_map[new_petal].base, self.vertex_petal_map[new_petal])
                        current_vertex = self.vertex_petal_map[new_petal].base

        return path

    # ******************************
    # Augment along a found path
    # ******************************
    def augment(self, left_support: List[int], right_support: List[int], bridge: Edge) -> bool:
        """
        Augment the matching M with the agumenting path found.
        """
        left_path = self.get_path(left_support, bridge[0])
        right_path = self.get_path(right_support, bridge[1])
        if not left_path or not right_path:
            # Could not construct a valid augmenting path
            return False

        # The left path needs to be reversed to go from the free vertex to the bridge vertex
        left_path.reverse()
        path = left_path + right_path

        # Toggle edges along the path: matched edges become unmatched and vice versa
        for index in range(len(path) - 1):
            u, v = path[index], path[index+1]
            label = self.G.edge_label(u, v)
            if self.M.has_edge(u, v, label):
                self.M.delete_edge(u, v, label)
            else:
                self.M.add_edge(u, v, label)

        # Erase vertex based on search level
        erase_vertex_list = []
        for vertex in path:
            self.deletion_phase[vertex] = self.phase_index
            erase_vertex_list.append(vertex)

        while erase_vertex_list:
            current_vertex = erase_vertex_list.pop()
            successors = self.successor[current_vertex][:]
            for vertex in successors:
                if self.deletion_phase[vertex] != self.phase_index:
                    self.predecessor[vertex].remove(current_vertex)
                    self.successor[current_vertex].remove(vertex)
                    if not self.predecessor[vertex]:
                        erase_vertex_list.append(vertex)
                        self.deletion_phase[vertex] = self.phase_index
        return True

    # Procedure to find path after discovering an augmenting path via DDFS
    def get_path(self, support: List[int], peak: int) -> List[int]:
        """
        Build the vertex sequence of an augmenting path.
        """
        path = []
        current_vertex = peak
        predecessor_list = self.predecessor[current_vertex][:]

        # Follow the support given to get the path
        for vertex in support:

            # Do a search following the trail given by the support
            while self.get_bud(current_vertex) != vertex:
                # If it is not the correct vertex pop the next vertex in the predecessor list
                current_vertex = predecessor_list.pop()

            predecessor_list = self.predecessor[current_vertex][:]
            # If the vertex is not part of a petal, add it to the path
            # Otherwise unfold the petal
            if self.vertex_petal_map[current_vertex] is None:
                path.append(current_vertex)
            else:
                petal_path = self.unfold_petal(current_vertex, self.get_bud(current_vertex))
                if not petal_path:
                    return []
                path += petal_path
                current_vertex = self.get_bud(current_vertex)
                predecessor_list = self.predecessor[current_vertex][:]
        return path

    # ******************************
    # Main: search phases
    # This is the main loop that finds and aguments phases (a maximal set of minimum length disjoin augmenting paths) and erase those vertices judiciously.
    # ******************************
    def search(self) -> bool:
        """
        Perform one complete search phase to find and augment any disjoint augmenting paths.
        Returns True if any augmentation was found.
        """
        search_level = 0
        augmentation_found = False
        search_complete = False
        while not augmentation_found and not search_complete:
            search_complete = self.MIN(search_level)
            augmentation_found = self.MAX(search_level)
            if search_complete and not self.num_augmentations:
                return False

            search_level += 1
        return True

    # ******************************
    # Algorithm execution flow
    # ******************************
    def get_matching(self) -> EdgesView:
        """
        Return an `EdgesView` of the maximum cardinality matching in `G`
        """
        if not self.G.size():
            return EdgesView(self.M)

        there_exists_a_phase = True
        self.compute_initial_maximal_matching()

        self.start_new_phase()
        while there_exists_a_phase:
            self.num_augmentations = 0
            there_exists_a_phase = self.search()
            self.phase_index += 1
            self.start_new_phase()

            # Stop early if perfect matching found
            if self.M.size() == self.N // 2:
                break

        # map the numeric vertex labels back to the original labels
        self.M.relabel(self.index_to_vertex, inplace=True)
        return EdgesView(self.M)