from typing import Any, List, Optional, Tuple, Union

from sage.rings.ring import CommutativeRing
from sage.rings.integer import Integer
from sage.libs.gmp.types import mpz_t

def is_IntegerRing(x: Any) -> bool:
    ...

class IntegerRing_class(CommutativeRing):
    def __init__(self) -> None:
        ...

    def __reduce__(self) -> Tuple:
        ...

    def __hash__(self) -> int:
        ...

    def __richcmp__(self, right: Any, op: int) -> bool:
        ...

    def _repr_(self) -> str:
        ...

    def _latex_(self) -> str:
        ...

    def __getitem__(self, x: Any) -> Any:
        ...

    def range(self, start: Any, end: Optional[Any] = None, step: Optional[Any] = None) -> List[Integer]:
        ...

    def __iter__(self) -> Any:
        ...

    def _coerce_map_from_(self, S: Any) -> Optional[Any]:
        ...

    def random_element(self, x: Optional[Any] = None, y: Optional[Any] = None, distribution: Optional[str] = None) -> Integer:
        ...

    def _randomize_mpz(self, value: mpz_t, x: Optional[Any], y: Optional[Any], distribution: Optional[str]) -> int:
        ...

    def _is_valid_homomorphism_(self, codomain: Any, im_gens: List[Any], base_map: Optional[Any] = None) -> bool:
        ...

    def _repr_option(self, key: str) -> Any:
        ...

    def is_field(self, proof: bool = True) -> bool:
        ...

    def fraction_field(self) -> Any:
        ...

    def extension(self, poly: Any, names: Any, **kwds: Any) -> Any:
        ...

    def quotient(self, I: Any, names: Optional[Any] = None, **kwds: Any) -> Any:
        ...

    def residue_field(self, prime: Any, check: bool = True, names: Optional[Any] = None) -> Any:
        ...

    def gens(self) -> Tuple[Integer]:
        ...

    def gen(self, n: int = 0) -> Integer:
        ...

    def ngens(self) -> int:
        ...

    def degree(self) -> int:
        ...

    def absolute_degree(self) -> int:
        ...

    def characteristic(self) -> Integer:
        ...

    def krull_dimension(self) -> int:
        ...

    def completion(self, p: Any, prec: int, extras: Optional[dict] = {}) -> Any:
        ...

    def order(self) -> Any:
        ...

    def zeta(self, n: int = 2) -> Integer:
        ...

    def parameter(self) -> Integer:
        ...

    def _roots_univariate_polynomial(self, p: Any, ring: Optional[Any] = None, multiplicities: bool = True, algorithm: Optional[str] = None) -> List[Union[Tuple[Integer, int], Integer]]:
        ...

    def _gap_init_(self) -> str:
        ...

    def _fricas_init_(self) -> str:
        ...

    def _magma_init_(self, magma: Any) -> str:
        ...

    def _macaulay2_init_(self, macaulay2: Optional[Any] = None) -> str:
        ...

    def _polymake_init_(self) -> str:
        ...

    def _sympy_(self) -> Any:
        ...

    def _sage_input_(self, sib: Any, coerced: bool) -> Any:
        ...

    def valuation(self, p: Any) -> Any:
        ...

    def from_bytes(self, input_bytes: Any, byteorder: str = 'big', is_signed: bool = False) -> Integer:
        ...

ZZ = IntegerRing_class()
Z = ZZ

def IntegerRing() -> IntegerRing_class:
    ...

def crt_basis(X: List[Integer], xgcd: Optional[Any] = None) -> List[Integer]:
    ...
