# -*- coding: utf-8 -*-
r"""
Twisted Cubics

The variety of nets of quadrics defining twisted cubics relative to a base.

We briefly explain the algorithm of Ellingsrud and Strømme in order to compute
the variety of nets of quadrics defining twisted cubics as well as
the incidence variety relative to a base.

Let `E_0` and `F_0` denote vector spaces of dimension `3` and `2`, respectively,
considered as representations of the group `G={\text{Gl}}_3\times{\text{Gl}}_2`
via the standard action of the left and right factor, respectively.
If `L=\det(E)\otimes  \det(F)^*`, then the restriction of the representations
`E\otimes  L^*` and `F\otimes  L^*` to the diagonal subgroup
`\Delta=\{(t I_3, tI_2)\;|\; t\in {\mathbb C}^*\}`
are trivial.

Let `W` denote a locally free sheaf on a scheme `S` and let
`U:={\text{SHom}}(E_0,F_0\otimes  W)` denote the `S`-scheme of linear maps
`A:E_0\to F_0\otimes _{\mathbb C} W_s`, `s\in S`.
The open subset `U^{ss}\subset U` of semistable points for the action of `G` on
`U` consists of matrices `A` such that there are no non-zero subspaces
`F'\subset F_0` and `E'\subset E_0` with `A(F_0)\subset E_0\otimes  W` and
`\dim(E')/\dim(F')< \dim(E_0)/\dim(F_0)`. Let `b:X_W\to S` denote the
GIT-quotient of `U^{ss}` by the action of `G`.

The cohomology ring of `X_W` can be described as follows: The stabilizer
subgroup of any point in `U^{ss}` is the diagonal group `\Delta`. Since this
group acts trivially on `{\mathcal O}_U\otimes  (E_0\otimes  L^*)` and
`{\mathcal O}_U\otimes  (F_0\otimes  L^*)`, these bundles descend to vector
bundles `E` and `F` (of rank `3` and `2`, resp.) on `X_W`, and there is a
tautological homomorphism `a:F\to E\otimes  b^*W`.
The Chern classes `e_1,e_2,e_3` of `E` and `f_1,f_2` of `F` generate
`H^*(X_W,{\mathbb Q})` as an `H^*(S,{\mathbb Q})`-algebra.
One checks directly that `\det(E)=\det(F)` so that `e_1=f_1`.

Let `t:T\to X_W` denote the variety of pairs of full flags of `F` and `E`, and
let

.. math::

    0\subset B_1\subset t^*F,\quad 0\subset A_1\subset A_2 \subset t^*E

denote the universal flag of subsheaves. As `H^*(S,{\mathbb Q})`-algebra, the
cohomology ring of `T` is generated by the Chern roots

.. math::
    b_1=c_1(B_1),\; b_2=c_1(t^*F/B_1),\quad\quad a_1=c_1(A_1),
    a_2=c_1(A_2/A_1), a_3=c_1(t^*E/A_2).

In particular, the classes `f_1,f_2` and `e_1,e_2,e_3` are the elementary
symmetric polynomials of the `b_1,b_2` and `a_1,a_2,a_3`, respectively.
The composite homomorphism

.. math::

    B_1\to t^*F\to t^*E\otimes  W\to (t^*E/A_1)\otimes  W\text{ and }t^*F\to
    t^*E\otimes  W\to (t^*E/A_2)\otimes  W

cannot vanish anywhere on `T` due to the semi-stability of the points on
in `X_W`. This implies that the top Chern class of the corresponding SHom-bundles
must vanish, which yields the relations

.. math::

    c_8{\mathcal H}om(B_1,(t^*E/A_1)\otimes  W)=0,\quad
    c_8{\mathcal H}om(t^*F, (t^*E/A_2)\otimes  W)=0.

The relations of the Chow-ring of `X_W` are now the coefficients of these Chern
classes with respect to a basis of `H^*(S,{\mathbb Q})[a_1,a_2,a_3,b_1,b_2]`
considered as a finite free module over
`H^*(S,{\mathbb Q})[f_1,f_2,e_1,e_1,e_3]` plus the relation `e_1=f_2`.

The tangent bundle is computed using the exact sequence,

.. math::

    0 \rightarrow\mathcal{O}_X\rightarrow End(E)\oplus End(F)\rightarrow
    SHom(F,E\otimes W)\rightarrow TX\rightarrow 0

This is implemented in :meth:`variety_of_nets_of_quadrics`.

The incidence variety can be obtained in a two-step process
`I_W={\mathbb P}(K_1^*)\xrightarrow{v} {\mathbb P}(W)\xrightarrow{u} S`, where
`0\to K_1\to u^*W\to L_1\to 0` is the tautological sequence on
`{\mathbb P}(W)`.

This is implemented in :meth:`incidence_variety`.

Also, let `0\to K_2\to v^*K_1^*\to L_2\to 0` be the tautological sequence on
`I_W`. Since the Chow ring of `H^*(X_W)` is generated by the Chern classes of
`E` and `F`, the embedding `f:I_W\to X_W` is determined as soon as one can
identify `f^*E` and `f^*F`. According to Ellingsrud and Strømme,
these bundles are
`f^*E= K_1\otimes  L_2^*` and `f^*F=K_2\otimes  L_2^*\otimes  \det(K_1)`.

Finally the morphism `f` is implemented in
:meth:`map_incidence_to_nets_of_quadrics`.

REFERENCE:

    Ellingsrud, Geir and Strømme, Stein Arild:
    The number of twisted cubics on the general quintic threefold,
    Math. Scand. 76 (1995) 5-34

AUTHORS:

- Manfred Lehn (2013)
- Christoph Sorger (2013)
"""

# ****************************************************************************
#       Copyright (C) 2013 Manfred Lehn <lehn@mathematik.uni-mainz.de>
#       Copyright (C) 2013 Christoph Sorger <christoph.sorger@univ-nantes.fr>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
# ****************************************************************************

from sage.all import QQ
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.polynomial.term_order import TermOrder
from sage.schemes.chow.bundle import Bundle, TrivialBundle
from sage.schemes.chow.scheme import ChowScheme
from sage.schemes.chow.finite_ring_extension import FiniteRingExtension
from sage.schemes.chow.sheaf import SHom, SEnd
from sage.schemes.chow.library.proj import ProjBundle


###############################################################################
#   The variety of nets of quadrics defining twisted cubics over S            #
###############################################################################
def variety_of_nets_of_quadrics(W, name=None, latex_name=None):
    r"""
    Returns the variety of nets of quadrics defining twisted cubics relative
    to `S` and a rank `4` vector bundle `W` of `S`.

    If S is given as parameter the variety will be relative to this instance
    of S.

    EXAMPLES::

        sage: P = PointChowScheme
        sage: W = Bundle(P, 4, [1])
        sage: X = variety_of_nets_of_quadrics(W)
        sage: X.euler_number()
        58
        sage: top = X.tangent_bundle().chern_classes()[X.dimension()]
        sage: top.integral() == X.euler_number()
        True

        sage: P = Grass(1, 5, 'w')
        sage: W = P.sheaves["universal_quotient"]
        sage: X = variety_of_nets_of_quadrics(W)
        sage: X.euler_number()
        290
        sage: top = X.tangent_bundle().chern_classes()[X.dimension()]
        sage: top.integral() == X.euler_number()
        True
    """

    # Base
    S = W.chowscheme()
    S_vars = list(S.variable_names())
    S_gens = list(S.gens())
    S_rels = [str(rel) for rel in S.rels()]
    S_dim = S.dimension()
    S_degs = list(S.degs())

    # The ChowScheme for A^*(S,{\mathbb Q})[e_1,e_2,e_3,f_1,f_2]
    variables = ['e1', 'e2', 'e3', 'f1', 'f2'] + S_vars
    degrees = [1, 2, 3, 1, 2] + S_degs
    Y = ChowScheme(12 + S_dim, variables, degrees, S_rels)
    Y = Y.base_change(Y.hom(S_vars, S))  # long time
    AY = Y.chowring()
    F = Bundle(Y, 2, ['1', 'e1', 'f2'])

    # The ChowScheme for A^*(S,{\mathbb Q})[a_1,a_2,a_3,b_1,b_2]
    variables = ['a1', 'a2', 'a3', 'b1', 'b2'] + S_vars
    degrees = [1, 1, 1, 1, 1] + S_degs
    Z = ChowScheme(12 + S_dim, variables, degrees, S_rels)
    Z = Z.base_change(Z.hom(S_vars, S))
    AZ = Z.chowring()
    a1, a2, a3, b1, b2 = AZ('a1'), AZ('a2'), AZ('a3'), AZ('b1'), AZ('b2')
    B1 = Bundle(Z, 1, [1, b1])
    Q1 = Bundle(Z, 2, [1, a2 + a3, a2 * a3])  # t^{*}E/A1
    Q2 = Bundle(Z, 1, [1, a3])  # t^{*}E/A2

    # The injection AY --> AZ given by the elementary symmetric polynomials:
    Af = AY.hom([a1 + a2 + a3, a1 * a2 + a1 * a3 + a2 * a3, a1 * a2 * a3,
                 b1 + b2, b1 * b2] + S_gens, AZ)
    t = Z.hom(Af, Y)
    ZW = Z.base_morphism().upperstar(W)
    U1 = SHom(B1, Q1 * ZW)
    U2 = SHom(t.upperstar(F), Q2 * ZW)
    J = [U1.chern_classes()[8], U2.chern_classes()[8]]

    A_f = FiniteRingExtension(Af)
    ideal_list = A_f.push_down(J).list()
    IRel = AY.ideal([str(l) for l in ideal_list])

    # IRel contains the relations. Cleaning up:

    # a) Simplify::

    from sage.libs.singular.function import singular_function
    simplify = singular_function('simplify')

    to = TermOrder('wdegrevlex', tuple([1, 2, 3, 1, 2] + S_degs))
    C = PolynomialRing(QQ, 5 + S.ngens(),
                       names=['e1', 'e2', 'e3', 'f1', 'f2'] + S_vars, order=to)
    CI = C.ideal([str(x) for x in IRel.gens()])
    CI = simplify(CI, 15, ring=C)

    # b) e1 = f1::
    #
    to = TermOrder('wdegrevlex', tuple([1, 2, 3, 2] + S_degs))
    D = PolynomialRing(QQ, 4 + S.ngens(),
                       names=['e1', 'e2', 'e3', 'f2'] + S_vars, order=to)
    e1, f1 = C('e1'), C('f1')
    ideal_list = [x.subs({f1: e1}) for x in CI] + S_rels
    DI = D.ideal([str(l) for l in ideal_list])

    # Define X
    dimension = 12 + S_dim
    generators = ['e1', 'e2', 'e3', 'f2'] + S_vars
    degrees = [1, 2, 3, 2] + S_degs
    relations = [str(rel) for rel in DI.gens()]
    X = ChowScheme(dimension, generators, degrees, relations,
                   name=name, latex_name=latex_name)
    # Make X relative to S : X --> S
    X = X.base_change(X.hom(S_vars, S))

    # The Universal sheaves (recall e1=f1)
    E = Bundle(X, 3, ['1', 'e1', 'e2', 'e3'])
    F = Bundle(X, 2, ['1', 'e1', 'f2'])

    # Compute the tangent bundle
    OX = TrivialBundle(X, 1)
    XW = X.base_morphism().upperstar(W)
    TX_S = OX + SHom(F, E * XW) - (SEnd(E) + SEnd(F))
    TX = TX_S + X.base_morphism().upperstar(S.tangent_bundle())
    X.sheaves["tangent"] = TX
    X.sheaves["E"] = E
    X.sheaves["F"] = F

    # Compute the point class
    A1 = SHom(TrivialBundle(X, 3), E)
    A2 = SHom(TrivialBundle(X, 2), F)
    A = A2 + A1
    B = SHom(TrivialBundle(X, 2), E * TrivialBundle(X, 4))
    from sage.schemes.chow.bundle import BundleDiffRelations
    r = X.chowring()(BundleDiffRelations(B, A)[0])
    X_S_pc = X.base_morphism().upperstar(S.point_class())
    X.set_point_class(r * X_S_pc)

    return X


def incidence_variety(W, name=None, latex_name=None):
    r"""
    The Incidence variety I.

    EXAMPLES::

        sage: P = PointChowScheme
        sage: W = Bundle(P, 4, [1])
        sage: I = incidence_variety(W)
        sage: I.dimension()
        5
        sage: I.euler_number()
        12
        sage: I.betti_numbers()
        [1, 2, 3, 3, 2, 1]
        sage: c5 = I.tangent_bundle().chern_classes()[5]
        sage: c5.integral() == I.euler_number()
        True

        sage: P = Grass(1, 5, 'w')
        sage: W = P.sheaves["universal_quotient"]
        sage: I = incidence_variety(W)
        sage: I.betti_numbers()
        [1, 3, 6, 9, 11, 11, 9, 6, 3, 1]
        sage: I.euler_number()
        60
        sage: top = I.tangent_bundle().chern_classes()[I.dimension()]
        sage: top.integral() == I.euler_number()
        True

        sage: G = Grass(6, 4, 'w')
        sage: W = G.sheaves["universal_quotient"]
        sage: I = incidence_variety(W)
        sage: I.betti_numbers()
        [1, 3, 7, 12, 18, 23, 26, 26, 23, 18, 12, 7, 3, 1]
        sage: I.euler_number()
        180
        sage: top = I.tangent_bundle().chern_classes()[I.dimension()]
        sage: top.integral() == I.euler_number()
        True

    """

    PW = ProjBundle(W, 'y')
    u = PW.base_morphism()
    K1 = PW.sheaves["universal_sub"]
    L1 = PW.sheaves["universal_quotient"]

    IV = ProjBundle(K1.dual(), 'x', name=name, latex_name=latex_name)
    v = IV.base_morphism()
    IV.sheaves["K1"] = v.upperstar(K1)
    IV.sheaves["L1"] = v.upperstar(L1)

    w = u * v
    IV = IV.base_change(w)
    IV.sheaves["K2"] = IV.sheaves["universal_sub"]
    IV.sheaves["L2"] = IV.sheaves["universal_quotient"]

    return IV


def map_incidence_to_nets_of_quadrics(W, domain_name=None, codomain_name=None,
                                      latex_domain_name=None,
                                      latex_codomain_name=None):
    r"""
    Returns the map `f:I_S\rightarrow X_S` from the incidence
    variety to the variety of nets of quadrics.

    EXAMPLES::

        sage: P = PointChowScheme
        sage: W = Bundle(P, 4, [1])
        sage: f = map_incidence_to_nets_of_quadrics(W)
    """
    S = W.chowscheme()

    IV = incidence_variety(W, name=domain_name, latex_name=latex_domain_name)
    IV_K1 = IV.sheaves["K1"]
    IV_K2 = IV.sheaves["K2"]
    IV_L2 = IV.sheaves["L2"]

    IE = IV_K1 * IV_L2.dual()
    IF = IV_K2 * IV_L2.dual() * IV_K1.determinant()
    X = variety_of_nets_of_quadrics(W, name=codomain_name,
                                    latex_name=latex_codomain_name)
    ie1 = IE.chern_classes()[1]
    ie2 = IE.chern_classes()[2]
    ie3 = IE.chern_classes()[3]
    if2 = IF.chern_classes()[2]
    f = IV.hom([ie1, ie2, ie3, if2] + list(S.gens()), X)
    return f
