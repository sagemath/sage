.. linkall

**********
接口
**********

Sage 的一个核心功能是它支持在通用接口和简洁的编程语言下，使用来自多个不同计算机代数系统的对象进行计算。

接口的 console 和 interact 方法的作用非常不同。例如，以 GAP 为例：


#. ``gap.console()``: 这会打开 GAP 控制台 - 将控制权转移给 GAP。
   在这里，Sage 只是充当一个方便的程序启动器，类似于 Linux 的 bash shell。

#. ``gap.interact()``: 这是与正在运行的 GAP 实例交互的便捷方式，
   该实例可能“装满了” Sage 对象。你可以将 Sage 对象导入到这个 GAP 会话中（甚至可以从交互界面中导入）等等。


.. index: PARI; GP

GP/PARI
=======

PARI 是一款小巧紧凑、非常成熟、高度优化的 C 程序，其主要关注点是数论。
Sage 中有两个截然不同的接口可供使用：


-  ``gp`` -- **PARI** 解释器

-  ``pari`` -- **PARI** C 库


例如，以下是同一任务的两种实现方法。它们看起来一样，但输出结果实际上是不同的，并且后台发生的事情也截然不同。

::

    sage: gp('znprimroot(10007)')
    Mod(5, 10007)
    sage: pari('znprimroot(10007)')
    Mod(5, 10007)

在第一种情况下，会启动一个单独的 GP 解释器副本作为服务器，
并将字符串 ``'znprimroot(10007)'`` 发送给它，经 GP 计算后，
结果被赋予 GP 中的一个变量（该变量占用子 GP 进程内存中的空间，不会被释放）。
然后显示该变量的值。
在第二种情况下，没有启动单独的程序，并且字符串 ``'znprimroot(10007)'`` 被某个 PARI C 库函数计算。
结果存储在 Python 的堆内存中，当该变量不再被引用时，该内存将被释放。对象具有不同的类型：

::

    sage: type(gp('znprimroot(10007)'))
    <class 'sage.interfaces.gp.GpElement'>
    sage: type(pari('znprimroot(10007)'))
    <class 'cypari2.gen.Gen'>

那么应该使用哪一种呢？这取决于你的需求。
GP 接口可以完成在通常的 GP/PARI 命令行程序中你可以做的任何任务，
尤其是你可以加载复杂的 PARI 程序并运行它们。
而使用 PARI 接口（通过 C 库）限制要多得多。
首先，所有的成员函数尚未完全实现。
其次，许多代码，例如涉及数值积分的代码，通过 PARI 接口无法工作。
话虽如此，PARI 接口显著比 GP 接口更快、更稳健。

（如果 GP 接口在计算给定输入时内存耗尽，它会静默地自动将堆栈大小加倍并重试该输入。
因此，如果你没有正确预估所需的内存，你的计算也不会崩溃。这是通常的 GP 解释器似乎不提供的一个不错的技巧。
对于 PARI C 库接口，它会立即将每个创建的对象从 PARI 堆栈中复制出来，因此堆栈不会增长。
然而，每个对象的大小不得超过 100MB，否则在创建对象时堆栈将溢出。
这个额外的复制会导致一定的性能损耗。）

总的来说，Sage 使用 PARI C 库提供了与 GP/PARI 解释器类似的功能，
不同之处在于具有不同的复杂内存管理和 Python 编程语言。

首先，我们从 Python 列表创建一个 PARI 列表。

::

    sage: v = pari([1,2,3,4,5])
    sage: v
    [1, 2, 3, 4, 5]
    sage: type(v)
    <class 'cypari2.gen.Gen'>

每个 PARI 对象的类型都是 ``Gen``。
底层对象的 PARI 类型可以使用 ``type`` 成员函数来获取。

::

    sage: v.type()
    't_VEC'

在 PARI 中，要创建一个椭圆曲线，我们输入 ``ellinit([1,2,3,4,5])``。
与 Sage 类似，除了 ``ellinit`` 是一个可以在任何 PARI 对象上调用的方法，例如我们的 ``t_VEC`` `v`。

::

    sage: e = v.ellinit()
    sage: e.type()
    't_VEC'
    sage: pari(e)[:13]
    [1, 2, 3, 4, 5, 9, 11, 29, 35, -183, -3429, -10351, 6128487/10351]

现在我们有了一个椭圆曲线对象，我们可以计算关于它的一些信息。

::

    sage: e.elltors()
    [1, [], []]
    sage: e.ellglobalred()
    [10351, [1, -1, 0, -1], 1, [11, 1; 941, 1], [[1, 5, 0, 1], [1, 5, 0, 1]]]
    sage: f = e.ellchangecurve([1,-1,0,-1])
    sage: f[:5]
    [1, -1, 0, 4, 3]

.. index: GAP

.. _section-gap:

GAP
===

Sage 附带用于计算离散数学，尤其是群论的 GAP。

以下是 GAP 的 ``IdGroup`` 函数的例子。

::

    sage: G = gap('Group((1,2,3)(4,5), (3,4))')
    sage: G
    Group( [ (1,2,3)(4,5), (3,4) ] )
    sage: G.Center()
    Group( () )
    sage: G.IdGroup()
    [ 120, 34 ]
    sage: G.Order()
    120

我们可以在 Sage 中执行相同的计算，而无需显式调用 GAP 接口，如下所示：

::

    sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])
    sage: G.center()
    Subgroup generated by [()] of (Permutation Group with generators [(3,4), (1,2,3)(4,5)])
    sage: G.group_id()
    [120, 34]
    sage: n = G.order(); n
    120

对于某些 GAP 功能，你需要安装可选的 Sage 软件包。可以通过如下命令完成::

    sage -i gap_packages


Singular
========

Singular 提供了一个庞大且成熟的库，用于处理 Gröbner 基、多元多项式最大公因数、
平面曲线上的 Riemann-Roch 空间基，以及因式分解等。我们将使用 Sage 接口来展示多元多项式的因式分解
（请勿输入 ``....:``）:

::

    sage: R1 = singular.ring(0, '(x,y)', 'dp')
    sage: R1
    polynomial ring, over a field, global ordering
    // coefficients: QQ...
    // number of vars : 2
    //        block   1 : ordering dp
    //                  : names    x y
    //        block   2 : ordering C
    sage: f = singular('9*y^8 - 9*x^2*y^7 - 18*x^3*y^6 - 18*x^5*y^6 +'
    ....:     '9*x^6*y^4 + 18*x^7*y^5 + 36*x^8*y^4 + 9*x^10*y^4 - 18*x^11*y^2 -'
    ....:     '9*x^12*y^3 - 18*x^13*y^2 + 9*x^16')

现在我们已经定义了 :math:`f`，我们输出它并进行因式分解。

::

    sage: f
    9*x^16-18*x^13*y^2-9*x^12*y^3+9*x^10*y^4-18*x^11*y^2+36*x^8*y^4+18*x^7*y^5-18*x^5*y^6+9*x^6*y^4-18*x^3*y^6-9*x^2*y^7+9*y^8
    sage: f.parent()
    Singular
    sage: F = f.factorize(); F
    [1]:
       _[1]=9
       _[2]=x^6-2*x^3*y^2-x^2*y^3+y^4
       _[3]=-x^5+y^2
    [2]:
       1,1,2
    sage: F[1][2]
    x^6-2*x^3*y^2-x^2*y^3+y^4

与 :ref:`section-gap` 中的 GAP 示例一样，
我们可以计算上述因式分解而无需显式调用 Singular 接口
（然而，Sage 实际上在后台使用 Singular 接口来进行实际计算）。
请勿输入 ``....:``：

::

    sage: x, y = QQ['x, y'].gens()
    sage: f = (9*y^8 - 9*x^2*y^7 - 18*x^3*y^6 - 18*x^5*y^6 + 9*x^6*y^4
    ....:     + 18*x^7*y^5 + 36*x^8*y^4 + 9*x^10*y^4 - 18*x^11*y^2 - 9*x^12*y^3
    ....:     - 18*x^13*y^2 + 9*x^16)
    sage: factor(f)
    (9) * (-x^5 + y^2)^2 * (x^6 - 2*x^3*y^2 - x^2*y^3 + y^4)

.. _section-maxima:

Maxima
======

Maxima 包括在 Sage 中，采用 Lisp 实现。
gnuplot 包（Maxima 默认用于绘图）作为 Sage 的可选包分发。
除其他功能外，Maxima 还可以进行符号操作。
Maxima 可以符号化积分和微分函数，求解一阶常微分方程（ODE），
大部分线性二阶常微分方程，并且已经实现了对任意阶线性常微分方程的拉普拉斯变换方法。
Maxima 还了解各种特殊函数，拥有通过 gnuplot 进行绘图的能力，
并且具有求解和操作矩阵（如行化简、特征值和特征向量），以及多项方程的方法。

我们通过构造一个矩阵来说明 Sage/Maxima 接口。
对于 :math:`i,j=1,\ldots,4`，该矩阵的 :math:`i,j` 项为 :math:`i/j`。

::

    sage: f = maxima.eval('ij_entry[i,j] := i/j')
    sage: A = maxima('genmatrix(ij_entry,4,4)'); A
    matrix([1,1/2,1/3,1/4],[2,1,2/3,1/2],[3,3/2,1,3/4],[4,2,4/3,1])
    sage: A.determinant()
    0
    sage: A.echelon()
    matrix([1,1/2,1/3,1/4],[0,0,0,0],[0,0,0,0],[0,0,0,0])
    sage: A.eigenvalues()
    [[0,4],[3,1]]
    sage: A.eigenvectors().sage()
    [[[0, 4], [3, 1]], [[[1, 0, 0, -4], [0, 1, 0, -2], [0, 0, 1, -4/3]], [[1, 2, 3, 4]]]]

下面是另一个例子:

::

    sage: A = maxima("matrix ([1, 0, 0], [1, -1, 0], [1, 3, -2])")
    sage: eigA = A.eigenvectors()
    sage: V = VectorSpace(QQ,3)
    sage: eigA
    [[[-2,-1,1],[1,1,1]],[[[0,0,1]],[[0,1,3]],[[1,1/2,5/6]]]]
    sage: v1 = V(sage_eval(repr(eigA[1][0][0]))); lambda1 = eigA[0][0][0]
    sage: v2 = V(sage_eval(repr(eigA[1][1][0]))); lambda2 = eigA[0][0][1]
    sage: v3 = V(sage_eval(repr(eigA[1][2][0]))); lambda3 = eigA[0][0][2]

    sage: M = MatrixSpace(QQ,3,3)
    sage: AA = M([[1,0,0],[1, - 1,0],[1,3, - 2]])
    sage: b1 = v1.base_ring()
    sage: AA*v1 == b1(lambda1)*v1
    True
    sage: b2 = v2.base_ring()
    sage: AA*v2 == b2(lambda2)*v2
    True
    sage: b3 = v3.base_ring()
    sage: AA*v3 == b3(lambda3)*v3
    True

最后，我们给出一个使用 Sage 进行 ``openmath`` 绘图的例子。
其中许多内容都是根据 Maxima 参考手册改编而来。

绘制多个函数的二维图像（请勿输入 ``....:``）::

    sage: maxima.plot2d('[cos(7*x),cos(23*x)^4,sin(13*x)^3]','[x,0,1]',  # not tested
    ....:     '[plot_format,openmath]')

可以用鼠标移动的“动态”三维图（请勿输入 ``....:``）::

    sage: maxima.plot3d ("2^(-u^2 + v^2)", "[u, -3, 3]", "[v, -2, 2]",  # not tested
    ....:     '[plot_format, openmath]')
    sage: maxima.plot3d("atan(-x^2 + y^3/4)", "[x, -4, 4]", "[y, -4, 4]",  # not tested
    ....:     "[grid, 50, 50]",'[plot_format, openmath]')

接下来的绘图是著名的莫比乌斯带（请勿输入 ``....:``）::

    sage: maxima.plot3d("[cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)), y*sin(x/2)]",  # not tested
    ....:     "[x, -4, 4]", "[y, -4, 4]", '[plot_format, openmath]')

接下来的绘图是著名克莱因瓶（请勿输入 ``....:``）::

    sage: maxima("expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)+ 3.0) - 10.0")
    5*cos(x)*(sin(x/2)*sin(2*y)+cos(x/2)*cos(y)+3.0)-10.0
    sage: maxima("expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)+ 3.0)").sage()
    -5*(cos(1/2*x)*cos(y) + sin(1/2*x)*sin(2*y) + 3.0)*sin(x)
    sage: maxima("expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))")
    5*(cos(x/2)*sin(2*y)-sin(x/2)*cos(y))
    sage: maxima.plot3d ("[expr_1, expr_2, expr_3]", "[x, -%pi, %pi]",  # not tested
    ....:     "[y, -%pi, %pi]", "['grid, 40, 40]", '[plot_format, openmath]')
