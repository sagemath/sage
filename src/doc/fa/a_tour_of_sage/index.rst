.. _a-tour-of-sage:

========
تور Sage
========

این بخش تور Sage است که شباهت زیادی به تور Mathematica که در ابتدای کتاب Mathematica است را دنبال می‌کند.


Sage به عنوان ماشین‌حساب 
==========================

خط فرمان Sage دارای اعلان ``sage:`` است. لازم نیست آن را اضافه کنید. اگر از  Sage notebook استفاده می‌کنید، همه چیز را پس از اعلان ``sage:`` در یک سلول ورودی قرار دهید، و کلید shift-enter را فشار دهید تا خروجی مربوطه محاسبه شود.

::

    sage: 3 + 5
    8

نماد مکان‌نما به معنای "به توان رسیدن" است.

::

    sage: 57.1 ^ 100
    4.60904368661396e175

معکوس :math:`2 \times 2` را در Sage محاسبه می‌کنیم.

::

    sage: matrix([[1,2], [3,4]])^(-1)
    [  -2    1]
    [ 3/2 -1/2]

در اینجا ما یک تابع ساده را ادغام می‌کنیم.

::

    sage: x = var('x')   # create a symbolic variable
    sage: integrate(sqrt(x)*sqrt(1+x), x)
    1/4*((x + 1)^(3/2)/x^(3/2) + sqrt(x + 1)/sqrt(x))/((x + 1)^2/x^2 - 2*(x + 1)/x + 1) - 1/8*log(sqrt(x + 1)/sqrt(x) + 1) + 1/8*log(sqrt(x + 1)/sqrt(x) - 1)

دستور زیر از Sage می‌خواهد تا یک معادله درجه‌دوم را حل کند. نماد ``==`` نشان‌دهنده برابری در Sage است.

::

    sage: a = var('a')
    sage: S = solve(x^2 + x == a, x); S
    [x == -1/2*sqrt(4*a + 1) - 1/2, x == 1/2*sqrt(4*a + 1) - 1/2]

نتیجه، لیستی از برابری هاست.

.. link

::

    sage: S[0].rhs()
    -1/2*sqrt(4*a + 1) - 1/2

در حالت عادی، Sage می‌تواند توابع مفید مختلفی را ترسیم کند.

::

    sage: show(plot(sin(x) + sin(1.6*x), 0, 40))

.. image:: sin_plot.*


قدرت محاسبه در Sage 
====================

ابتدا یک ماتریس از :math:`500 \times 500` تصادفی ایجاد می‌کنیم.

::

    sage: m = random_matrix(RDF,500)

محاسبه مقادیر ویژه ماتریس و رسم آن‌ها برای Sage چند ثانیه طول خواهد‌کشید.

.. link

::

    sage: e = m.eigenvalues()  #about 2 seconds
    sage: w = [(i, abs(e[i])) for i in range(len(e))]
    sage: show(points(w))

.. image:: eigen_plot.*


به لطف کتابخانه Sage ،GNU Multipercision  (GMP) می‌تواند اعداد بسیار بزرگ، حتی اعداد با میلیون‌ها یا میلیاردها رقم را مدیریت کند.

::

    sage: factorial(100)
    93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
    sage: n = factorial(1000000)  #about 2.5 seconds

دستور زیر حداقل ۱۰۰ رقم :math:`\pi` را محاسبه می‌کند.

::

    sage: N(pi, digits=100)
    3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068

دستور زیر از Sage می خواهد یک چند جمله‌ای را در دو متغیر فاکتور بگیرد.

::

    sage: R.<x,y> = QQ[]
    sage: F = factor(x^99 + y^99)
    sage: F
    (x + y) * (x^2 - x*y + y^2) * (x^6 - x^3*y^3 + y^6) *
    (x^10 - x^9*y + x^8*y^2 - x^7*y^3 + x^6*y^4 - x^5*y^5 +
     x^4*y^6 - x^3*y^7 + x^2*y^8 - x*y^9 + y^10) *
    (x^20 + x^19*y - x^17*y^3 - x^16*y^4 + x^14*y^6 + x^13*y^7 -
     x^11*y^9 - x^10*y^10 - x^9*y^11 + x^7*y^13 + x^6*y^14 -
     x^4*y^16 - x^3*y^17 + x*y^19 + y^20) * (x^60 + x^57*y^3 -
     x^51*y^9 - x^48*y^12 + x^42*y^18 + x^39*y^21 - x^33*y^27 -
     x^30*y^30 - x^27*y^33 + x^21*y^39 + x^18*y^42 - x^12*y^48 -
     x^9*y^51 + x^3*y^57 + y^60)
    sage: F.expand()
    x^99 + y^99

Sage تنها کم‌تر از ۵ ثانیه طول می‌کشد تا تعداد راه‌هایی را برای پارتیشن‌بندی یک صد میلیون به عنوان مجموع اعداد صحیح مثبت محاسبه کند.

::

    sage: z = Partitions(10^8).cardinality() #about 4.5 seconds
    sage: str(z)[:40]
    '1760517045946249141360373894679135204009'

دسترسی الگوریتم‌ها در Sage 
============================

هر زمان که از Sage استفاده می‌کنید به یکی از بزرگترین مجموعه الگوریتم‌های محاسبات منبع باز جهان دسترسی پیدا می‌کنید.
