#!/usr/bin/env python3
"""Detect cyclic imports inside the ``sage`` package.

This script dynamically imports every module under ``src/sage`` while
recording failed imports and the resulting dependency chain. Results are printed in a human friendly form
and written to ``known-cyclic-imports.toml`` so that CI can guard against
new cycles being introduced.
"""

from __future__ import annotations

import argparse
import importlib
import importlib.util
import inspect
import multiprocessing
import re
import sys
import tomllib
import traceback
from pathlib import Path
from typing import TYPE_CHECKING, Generator, Sequence

if TYPE_CHECKING:
    from multiprocessing.queues import Queue

DEFAULT_TOML_PATH = Path(__file__).parent / "known-cyclic-imports.toml"


def discover_modules(package_root: Path) -> Generator[Path, None, None]:
    yield from package_root.glob("**/*.py")
    # TODO: Activate analysis of Cython files (currently not possible to create import spec)
    # yield from package_root.glob("**/*.pyx")


def clear_sage_modules() -> None:
    """Remove cached ``sage`` modules so they are fully re-imported."""
    for name in list(sys.modules):
        if name.startswith("sage"):
            sys.modules.pop(name, None)

    print(sys.modules.keys())


def print_cycles(
    cycles: list[tuple[str, ...]], cycle_to_exception: dict[tuple[str, ...], str]
) -> None:
    if not cycles:
        print("No cyclic imports detected.")
        return

    for cycle in cycles:
        starting = cycle[0]
        print(f"\nCycle starting at {starting}:")
        for module in cycle:
            print(f"  - {module}")
        exc = cycle_to_exception.get(cycle)
        if exc:
            print(exc)


def write_cycles_toml(
    path: Path,
    cycles: list[tuple[str, ...]],
    cycle_to_exception: dict[tuple[str, ...], str],
) -> None:
    lines: list[str] = [
        "# Auto-generated by tools/find_cyclic_imports.py â€” do not edit manually.\n",
        "# Run `tools/find_cyclic_imports.py` to refresh this file.\n\n",
    ]

    for cycle in cycles:
        lines.append("[[cycle]]\n")
        if len(cycle) == 1:
            lines.append(f'modules = ["{cycle[0]}"]\n\n')
            continue
        lines.append("modules = [\n")
        for module in cycle:
            lines.append(f'  "{module}",\n')
        lines.append("]\n")

        exc = cycle_to_exception.get(cycle)
        if exc:
            lines.append(exc)
        lines.append("\n")

    path.write_text("".join(lines), encoding="utf-8")


def load_known_cycles(path: Path) -> set[tuple[str, ...]]:
    if not path.exists():
        return set()

    text = path.read_text(encoding="utf-8")
    data = tomllib.loads(text)
    raw_cycles = data.get("cycle", []) if isinstance(data, dict) else []
    return {
        tuple(entry.get("modules", []))
        for entry in raw_cycles
        if isinstance(entry, dict)
    }


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--src",
        type=Path,
        default=Path(".") / "src" / "sage",
        help="Path to the `sage` package (default: %(default)s)",
    )
    parser.add_argument(
        "--write",
        nargs="?",
        const=DEFAULT_TOML_PATH,
        type=Path,
        default=None,
        help="Write the TOML summary to a file (default: %(const)s if flag is given without a path)",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Only verify that current cycles are listed in the TOML file; fail otherwise.",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Show full tracebacks when module imports fail.",
    )

    return parser.parse_args(argv)


def extract_imports_from_traceback(exc_tb) -> list[str]:
    imports: list[str] = []
    tb = exc_tb
    while tb is not None:
        frame = tb.tb_frame
        parent: str = frame.f_globals.get("__name__")
        if parent.startswith("sage."):
            imports.append(parent)
        tb = tb.tb_next
    return imports


def extract_failing_import(exc: Exception, modules: list[str]):
    """Extract the module that caused the import failure from the exception.

    For example, in "ImportError: cannot import name 'Category_singleton' from partially initialized module 'sage.categories.category_singleton'"
    we want to extract 'sage.categories.category_singleton'.
    Or in "AttributeError: partially initialized module 'sage.categories.map'" we want to extract 'sage.categories.map'.
    """
    if isinstance(exc, ImportError):
        msg = str(exc)
        match = re.search(r"from partially initialized module ['\"]([^'\"]+)['\"]", msg)
        if match:
            return match.group(1)

        # For Cython modules, we simply get: ImportError: cannot import name Sets
        # So we try to extract the missing module from the currently loaded modules
        match = re.search(r"cannot import name (.+)", msg)
        if match:
            name = match.group(1)
            for module_name in modules:
                try:
                    module = importlib.import_module(module_name)
                except Exception:
                    # Likely to fail due to half-initialized modules
                    continue
                members = inspect.getmembers(module)
                if any(m[0] == name for m in members):
                    return module_name

    elif isinstance(exc, AttributeError):
        msg = str(exc)
        match = re.search(r"partially initialized module ['\"]([^'\"]+)['\"]", msg)
        if match:
            return match.group(1)
        # Also handle: AttributeError: cannot access submodule 'function' of module 'sage.symbolic'
        match = re.search(
            r"cannot access submodule ['\"]([^'\"]+)['\"] of module ['\"]([^'\"]+)['\"]",
            msg,
        )
        if match:
            submodule, parent = match.group(1), match.group(2)
            return f"{parent}.{submodule}"
    return None


def import_module(file: Path, verbose: bool) -> tuple[list[str], str, str] | None:
    if file.name.startswith("all"):
        # These are used to fix cyclic imports, so skip them.
        return None
    if file.name == "__main__.py":
        # These are executables so skip them.
        return None
    if file.name.endswith("_test.py"):
        # These are tests so skip them.
        return None
    print(f"Importing {file}...\n", flush=True)
    try:
        spec = importlib.util.spec_from_file_location("module.name", file)
        if spec is None or spec.loader is None:
            if verbose:
                print(f"Failed to create import spec for {file}", file=sys.stderr)
            return None
        module = importlib.util.module_from_spec(spec)
        sys.modules["module.name"] = module
        spec.loader.exec_module(module)
    except Exception as exc:
        if isinstance(exc, ModuleNotFoundError) and exc.name == "module":
            # This is expected when a module uses relative imports
            # TODO: Convert relative imports to absolute imports
            return None

        modules = [
            module
            for module in extract_imports_from_traceback(exc.__traceback__)
            if module
        ]
        failing_module = extract_failing_import(exc, modules)
        if verbose:
            if failing_module:
                print(
                    f"Import failed due to cycle {modules} ending at {failing_module}"
                )
            else:
                print(
                    "Could not extract failing module from exception:", file=sys.stderr
                )
            traceback.print_exc()
        if not failing_module:
            return None
        exception_str = "# Example exception:\n"
        for line in traceback.format_exception(exc):
            for subline in line.splitlines():
                exception_str += f"# {subline}\n"
        return (modules, failing_module, exception_str)
    return None


def extract_cycle(modules: list[str], failing_module: str) -> tuple[str, ...]:
    """
    Extract the cycle of imports leading to the failure.
    """
    if not modules or not failing_module:
        return tuple()

    try:
        index = modules.index(failing_module)
        return tuple(modules[index:] + [failing_module])
    except ValueError:
        return tuple()


def _import_worker(
    file_str: str, verbose: bool, queue: Queue[tuple[list[str], str, str] | None]
) -> None:
    """Worker that runs import_module in a fresh process and puts the result on a queue."""
    try:
        res = import_module(Path(file_str), verbose)
    except BaseException:
        res = None
    queue.put(res)


def import_module_in_subprocess(
    file: Path, verbose: bool
) -> tuple[list[str], str, str] | None:
    """Run import_module in a new process and return its result."""
    ctx = multiprocessing.get_context("spawn")
    q: Queue[tuple[list[str], str, str] | None] = ctx.Queue()
    p = ctx.Process(target=_import_worker, args=(str(file), verbose, q), daemon=True)
    p.start()
    p.join()
    if p.exitcode == 0:
        try:
            return q.get_nowait()
        except Exception:
            return None
    else:
        if verbose:
            print(
                f"Subprocess for {file} exited with code {p.exitcode}", file=sys.stderr
            )
        return None


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv)

    source = args.src.resolve()
    if args.verbose:
        print(f'Discovering cyclic imports in "{source}"...')
    modules = discover_modules(source)

    cycles: set[tuple[str, ...]] = set()
    cycle_to_exception: dict[tuple[str, ...], str] = {}
    for file in modules:
        failure = import_module_in_subprocess(file, args.verbose)
        if failure:
            imports, failing_module, exc = failure
            cycle = extract_cycle(imports, failing_module)
            cycles.add(cycle)
            cycle_to_exception[cycle] = exc

    cycles_sorted = sorted(cycles, key=lambda group: group[0])

    print_cycles(cycles_sorted, cycle_to_exception)

    if args.check:
        expected = load_known_cycles(DEFAULT_TOML_PATH)
        missing = cycles - expected
        if missing:
            print("\nNew cyclic imports detected that are not listed in the TOML file:")
            for cycle in missing:
                formatted = ", ".join(cycle)
                print(f"  - {formatted}")
            return 1
        print(
            "\nAll detected cycles are acknowledged in the known-cyclic-imports.toml file."
        )
        return 0

    if args.write:
        output_path = args.write
        write_cycles_toml(output_path, cycles_sorted, cycle_to_exception)
        print(f"\nWrote {len(cycles)} cycle group(s) to {output_path}")
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entrypoint
    sys.exit(main())
